// env=undefined => env=publish 
Cube("datav:/com/datav-engine-sequence-animation/0.0.4/shaders/point.frag.glsl",[],function(a){return a.exports="#ifdef GL_ES\n  precision highp float;\n#define GLSLIFY 1\n#endif\n\n#include <logdepthbuf_pars_fragment>\n\nuniform sampler2D uTexture;\nuniform float uOpacity;\nuniform vec2 uTextureSegments; //horizontal and verticle segments of a texture, as frames of animation graph\nuniform float uFrameCursor; //represent which is the current animation frame\nvarying float vStartFrame;\n\nvec2 scaleUv(vec2 pCoord, vec2 transformStep, vec2 uTextureSegments) {\n  float uSegmentUnit = 1.0 / uTextureSegments.x;\n  float vSegmentUnit = 1.0 / uTextureSegments.y;\n  return vec2(pCoord.x / uTextureSegments.x + uSegmentUnit * transformStep.x, pCoord.y / uTextureSegments.y + vSegmentUnit * transformStep.y);\n}\n\n//>>> calculate the current frame of the counter ------\nvec2 calculateCurrentFrame(float uFrameCursor) {\n  float uFrameCursorModed;\n  float segmentLimit = uTextureSegments.x * uTextureSegments.y;\n\n  if(uFrameCursor >= segmentLimit) {\n    uFrameCursorModed = mod(uFrameCursor, segmentLimit); \n  } else {\n    uFrameCursorModed = uFrameCursor;\n  }\n\n  float transformStepX = mod(uFrameCursorModed, uTextureSegments.x);\n  float transformStepY = floor(uFrameCursorModed / uTextureSegments.x);\n  //reverse texture again of Y axis, but not work yet\n  // float transformStepY = uTextureSegments.y - floor(uFrameCursorModed / uTextureSegments.x); \n\n  return vec2(transformStepX, transformStepY);\n}\n\nvoid main() {\n  #include <logdepthbuf_fragment>\n  float segmentLimit = uTextureSegments.x * uTextureSegments.y;\n  float frameOffset = floor(vStartFrame * segmentLimit); //make a int start frame offset\n\n  // vec2 currentFrame = calculateCurrentFrame(uFrameCursor + frameOffset);\n  float floorFrameCursor = floor(uFrameCursor); //adaptive speed\n  vec2 currentFrame = calculateCurrentFrame(floorFrameCursor + frameOffset);\n  // vec2 currentFrame = calculateCurrentFrame(floorFrameCursor);\n\n  vec2 scaledUvs = scaleUv(gl_PointCoord, currentFrame, uTextureSegments);\n\n  vec4 fragColor = texture2D(uTexture, scaledUvs);\n\n  // if (fragColor.w < 0.01) { //to enable depth test\n  //   discard;\n  // }\n\n  gl_FragColor = fragColor * uOpacity;\n\n  #include <premultiplied_alpha_fragment>\n}",a.exports});;
Cube("datav:/com/datav-engine-sequence-animation/0.0.4/shaders/point.vert.glsl",[],function(a){return a.exports="#define GLSLIFY 1\n#include <logdepthbuf_pars_vertex>\n\n// uniform vec3 cameraPosition; // pre-defined camera position in world space\nuniform float uSize;\n\nattribute float aStartFrame;\nattribute float aOpacity;\n\n// varying float vPointIndex;\nvarying float vStartFrame;\n\nconst float maxDistance = 100000.0;\nconst float minPointScale = 1.0;\nconst float maxPointScale = 200.0;\nconst float scaleFactor = 10.0;\n\nfloat clampPointSize(float size, float minSize, float maxSize);\n\nvoid main() {\n  vStartFrame = aStartFrame;\n\n  float cameraDist = distance(position.xyz, cameraPosition);\n  float pointScale = 1.0 - (cameraDist / maxDistance);\n  pointScale = max(pointScale, minPointScale);\n  pointScale = min(pointScale, maxPointScale);\n  // pointScale = 1.0 / pointScale;\n\n  // gl_PointSize = uSize;\n  float pSize = uSize * scaleFactor * (1.0 / cameraDist);\n  gl_PointSize = clampPointSize(pSize, minPointScale, maxPointScale);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n  // gl_PointSize = gl_Position.w * pointScale;\n  // gl_PointSize = gl_Position.w / pointScale;\n  #include <logdepthbuf_vertex>\n}\n\nfloat clampPointSize(float size, float minSize, float maxSize) {\n  float pointSize = max(size, minSize);\n  pointSize = min(pointSize, maxSize);\n\n  return pointSize;\n}",a.exports});;
Cube("datav:/com/datav-engine-sequence-animation/0.0.4/layer",["datav:/npm/eventemitter3/3.0.0"],function(a,b,c){const d=c("datav:/npm/eventemitter3/3.0.0");return a.exports=class extends d{constructor(){super(),this.preSceneName="main",this.usingSceneName="main"}addTo(a){return a?void(this.viewer=a,this.Utils=a.Utils,this.controller=a.controller,this.scene=this.getAssignedScene(),this.viewer.on("projChanged",this.updatePostions.bind(this))):console.log("Layer needs viewer layer")}getProjPos(a,b,c){return this.viewer&&this.viewer.Projection([a,b,c])}updatePostions(){}getAssignedScene(){const a=this.options;return a.isSceneGroup&&a.sceneName?a.sceneName?this.controller.getScene(a.sceneName)?this.controller.getScene(a.sceneName):this.controller.createScene(a.sceneName):void 0:this.controller.getScene("main")}toggleScene(a,b,c){this.controller.switchScene(a,b,c).then(()=>{this.preSceneName=b,this.usingSceneName=c})}updateOptions(){}},a.exports});;
Cube("datav:/com/datav-engine-sequence-animation/0.0.4",[],function(a,b,c){let d=null,e=null;const f=c("datav:/com/datav-engine-sequence-animation/0.0.4/layer"),g=c("datav:/com/datav-engine-sequence-animation/0.0.4/shaders/point.vert.glsl"),h=c("datav:/com/datav-engine-sequence-animation/0.0.4/shaders/point.frag.glsl");return a.exports=class extends f{constructor(a,b){super(),this.options=Object.assign({isSceneGroup:!1,sceneName:"",size:100,pointsTexture:"https://img.alicdn.com/tfs/TB1m1WvXMmTBuNjy1XbXXaMrVXa-2048-2048.png",textureSegmentsX:8,textureSegmentsY:8,speed:0.5,opacity:1,heightPosition:0,visible:!0},b||{})}addTo(a){return a?void(super.addTo(a),d=a.three,e=a.Utils,this.animation=this.animation.bind(this),this.viewer.on("animationFrame",this.animation)):console.log("Layer needs viewer layer")}createMesh(a){let b=this.createPoints(a);return b}projectData(a){return a.map((a)=>{let b=this.getProjPos(a.x,a.y,a.z);return{x:b[0],y:b[1],z:b[2],value:a.value||1}})}setData(a){if(!a||!Array.isArray(a))return console.log("error: no data for animation marker component.");if(this.dispose(),!a.length)return console.log("error: wrong data format for animation marker component.");this._data=a;let b=this.projectData(a),c=this.createAttributeDataArray(b),d=this.attributesDataWrapper(c);this.componentMesh=this.createMesh(d),this.componentMesh.position.y=this.options.heightPosition,this.scene.add(this.componentMesh)}attributesDataWrapper(a){let b={positions:a.positions,values:a.values,pointsIndex:[],startFrame:[]};for(let c=0;c<b.positions.length/3;c++)b.pointsIndex.push(c),b.startFrame.push(Math.random());return b}createAttributeDataArray(a){let b={};return b.positions=[],b.values=[],a.forEach(function(a){b.positions.push(a.x),b.positions.push(a.y),b.positions.push(a.z),b.values.push(a.value)}),b}createPoints(a){this.pointsGeometry=new d.BufferGeometry,this.pointsGeometry.addAttribute("position",new d.BufferAttribute(new Float32Array(a.positions),3)),this.pointsGeometry.addAttribute("aPointIndex",new d.BufferAttribute(new Float32Array(a.pointsIndex),1)),this.pointsGeometry.addAttribute("aStartFrame",new d.BufferAttribute(new Float32Array(a.startFrame),1)),this.pointsTexture=new d.TextureLoader().setCrossOrigin("*"),this.pointsTexture.flipY=!1,this.textureSegmentsX=this.options.textureSegmentsX,this.textureSegmentsY=this.options.textureSegmentsY,this.textureSegmentsLimit=this.textureSegmentsX*this.textureSegmentsY,this.pointsMaterial=new d.ShaderMaterial({uniforms:{uTexture:{value:this.pointsTexture.load(this.options.pointsTexture)},uTextureSegments:{value:new d.Vector2(this.textureSegmentsX,this.textureSegmentsY)},uSize:{value:this.options.size},uOpacity:{value:this.options.opacity},uFrameCursor:{value:-this.textureSegmentsLimit}},vertexShader:g,fragmentShader:h,side:d.DoubleSide,sizeAttenuation:!0,blending:d.AdditiveBlending,depthTest:!0,transparent:!0});let b=new d.Points(this.pointsGeometry,this.pointsMaterial);return b.renderOrder=7001,b}animation(){this.pointsMaterial&&(this.pointsMaterial.uniforms.uFrameCursor.value>=this.textureSegmentsLimit?this.pointsMaterial.uniforms.uFrameCursor.value=0:this.pointsMaterial.uniforms.uFrameCursor.value+=this.options.speed)}updateUniformCounters(a,b,c,d,e){let f=a;return 1==e?(f+=d,f>=c&&(f=b)):(f-=d,f<=c&&(f=b)),f}checkVisible(){let a=this.options;a.visible?this.show():this.hide()}hide(){this.options.visible=!1,this.componentMesh&&(this.componentMesh.visible=!1)}show(){this.options.visible=!0,this.componentMesh&&(this.componentMesh.visible=!0)}updateOptions(a){const b=this.Utils.deepClone(this.options);this.options=this.Utils.mergeOptions(this.options,a||{}),this.Utils.easyDiff(b.sceneName,a.sceneName)||(this.scene=this.getAssignedScene(),this.toggleScene(this.componentMesh,this.usingSceneName,a.sceneName)),this.pointsMaterial.uniforms.uTexture.value=this.pointsTexture.load(this.options.pointsTexture),this.textureSegmentsX=this.options.textureSegmentsX,this.textureSegmentsY=this.options.textureSegmentsY,this.textureSegmentsLimit=this.textureSegmentsX*this.textureSegmentsY,this.pointsMaterial.uniforms.uTextureSegments.value=new d.Vector2(this.textureSegmentsX,this.textureSegmentsY),this.pointsMaterial.uniforms.uSize.value=this.options.size,this.pointsMaterial.uniforms.uOpacity.value=this.options.opacity,this.pointsMaterial.needsUpdate=!0,this.componentMesh.position.y=this.options.heightPosition,this.componentMesh.visible=this.options.visible}disposeNode(a){a.traverse((a)=>{if(a.geometry&&a.geometry.dispose(),a.material){let b;a.material instanceof d.MeshFaceMaterial||a.material instanceof d.MultiMaterial?b=a.material.materials:a.material instanceof Array&&(b=a.material),b?b.forEach((a)=>{a.map&&a.map.dispose(),a.lightMap&&a.lightMap.dispose(),a.bumpMap&&a.bumpMap.dispose(),a.normalMap&&a.normalMap.dispose(),a.specularMap&&a.specularMap.dispose(),a.envMap&&a.envMap.dispose(),a.dispose()}):(a.material.map&&a.material.map.dispose(),a.material.lightMap&&a.material.lightMap.dispose(),a.material.bumpMap&&a.material.bumpMap.dispose(),a.material.normalMap&&a.material.normalMap.dispose(),a.material.specularMap&&a.material.specularMap.dispose(),a.material.envMap&&a.material.envMap.dispose(),a.material.dispose())}})}disposeComponentMeshes(){this.componentMesh=null}dispose(){this.componentMesh&&(this.scene.remove(this.componentMesh),this.disposeNode(this.componentMesh),this.disposeComponentMeshes())}remove(){this.dispose(),this._data=null}},a.exports});