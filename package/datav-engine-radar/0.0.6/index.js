// env=undefined => env=publish 
Cube("datav:/com/datav-engine-radar/0.0.6/shaders/radar.frag.glsl",[],function(a){return a.exports="#ifdef GL_ES\n  precision highp float;\n#define GLSLIFY 1\n#endif\n\n#include <logdepthbuf_pars_fragment>\n\nuniform sampler2D uTexture;\nuniform float uTimeCounter;\nuniform float uAngle;\nuniform vec3 uColor;\nuniform float uLight;\nvarying vec2 vUv;\n\nvec2 rotateUv(float angle, vec2 uv);\nfloat calOpacityByPolarDistance(float polarLength, float startPoint);\nfloat calculateHightColor(float uvPosition, float thickness, float intensity);\nfloat calculateTimeGapOpacity(float timeCounter);\n// float softPolarEdge(float innerPoint, float outPoint, float edgelength);\nfloat softInnerPolarEdge(float polar, float startPoint, float edgelength);\nfloat softOutPolarEdge(float polar, float startPoint, float edgelength);\nfloat tweenBounceOut(float k);\nfloat tweenBounceIn(float k);\nfloat tweenBounceInOut(float k);\n\nvoid main() {\n  #include <logdepthbuf_fragment>\n\n  //draw the outside bubble ring\n  vec2 polarSt = vec2(atan(vUv.x-0.5, vUv.y-0.5), distance(vUv, vec2(0.5, 0.5)));\n\n  float thickness = 0.6;\n  float intensity = 1.5;\n  float transparentStartUv = 0.45;\n  float col = 25.0;\n  float uvY = polarSt.y * col;\n\n  float fractUvY = fract(uvY + uTimeCounter);\n  float centerY = 0.5;\n  float ringColor = calculateHightColor(fractUvY, thickness, intensity);\n\n  // if(polarSt.y <= 1.0) {\n  //   ringColor *= calOpacityByPolarDistance(polarSt.y, transparentStartUv);\n  // } else {\n  //   ringColor = 0.0;\n  // }\n\n  //draw the rotating radar wave with texture\n  vec2 rotatedUv = rotateUv(uAngle, vUv);\n  gl_FragColor = texture2D(uTexture, rotatedUv);\n\n  //compose radar wave, bubble ring, bubbles \n  float bubbleRingColor = 0.0;\n  if(polarSt.y <= 0.5 && polarSt.y >= 0.4) {\n    // bubbleRingColor = ringColor * calOpacityByPolarDistance(polarSt.y, 0.48) * softInnerPolarEdge(polarSt.y, 0.4, 0.02);\n    bubbleRingColor = ringColor * softOutPolarEdge(polarSt.y, 0.45, 0.05) * softInnerPolarEdge(polarSt.y, 0.4, 0.02);\n\n    bubbleRingColor *= calculateTimeGapOpacity(uAngle);\n  }\n\n  if(polarSt.y <= 0.05) {\n    bubbleRingColor = ringColor * softOutPolarEdge(polarSt.y, 0.03, 0.02);\n  }\n\n  gl_FragColor += bubbleRingColor;\n\n  //color the gray\n  vec4 colorMask = vec4(uColor, 1.0);\n  gl_FragColor *= colorMask;\n\n  gl_FragColor *= uLight;\n\n  #include <premultiplied_alpha_fragment>\n}\n\nvec2 rotateUv(float angle, vec2 uv) {\n  vec2 coord = uv;\n\n  float sin_factor = sin(angle);\n  float cos_factor = cos(angle);\n\n  // coord = vec2((coord.x - 0.5), (coord.y - 0.5)) * mat2(cos_factor, sin_factor, -sin_factor, cos_factor);\n\n  coord = (coord - 0.5) * mat2(cos_factor, sin_factor, -sin_factor, cos_factor);\n\n  coord += 0.5;\n\n  return coord;\n}\n\n// float softPolarEdge(float polar, float innerPoint, float outPoint, float edgelength) {\n//   if((outPoint - innerPoint) < edgelength * 2.0) {\n//     return 0.0;\n//   }\n\n//   if(polar >= innerPoint) {\n\n//   }\n// }\n\nfloat calculateHightColor(float uvPosition, float thickness, float intensity) {\n  float e = (0.5 - abs(uvPosition - 0.5)) / 0.5;\n  return pow(e * thickness, intensity);\n}\n\nfloat calOpacityByPolarDistance(float polarLength, float startPoint) {\n  float totalPolarLength = 0.5;\n  float opacity = 1.0;\n  if(polarLength > startPoint) {\n    float distancePercent = (totalPolarLength - polarLength) / (totalPolarLength - startPoint);\n    return pow(distancePercent, 2.0);\n  } else {\n    return 1.0;\n  }\n}\n\nfloat softInnerPolarEdge(float polar, float startPoint, float edgelength) {\n  if(polar >= startPoint && polar <= (startPoint + edgelength)) {\n    float distancePercent = (polar - startPoint) / edgelength;\n    return pow(distancePercent, 3.0);\n  } else {\n    return 1.0;\n  }\n}\n\nfloat softOutPolarEdge(float polar, float startPoint, float edgelength) {\n  if(polar >= startPoint && polar <= (startPoint + edgelength)) {\n    float distancePercent = (startPoint + edgelength - polar) / edgelength;\n    return pow(distancePercent, 3.0);\n  } else {\n    return 1.0;\n  }\n}\n\nfloat calculateTimeGapOpacity(float timeCounter) {\n  float opacity = sin(timeCounter);\n  if(opacity > 0.0) {\n    return opacity;\n  } else {\n    return 0.0;\n  }\n}\n\nfloat tweenBounceOut(float k) {\n  if (k < (1.0 / 2.75)) {\n    return 7.5625 * k * k;\n  } else if (k < (2.0 / 2.75)) {\n    return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n  } else if (k < (2.5 / 2.75)) {\n    return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n  } else {\n    return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n  }\n}\n\nfloat tweenBounceIn(float k) {\n  return 1.0 - tweenBounceOut(1.0 - k);\n}\n\nfloat tweenBounceInOut(float k) {\n  if (k < 0.5) {\n    return tweenBounceIn(k * 2.0) * 0.5;\n  }\n\n  return tweenBounceOut(k * 2.0 - 1.0) * 0.5 + 0.5;\n}",a.exports});;
Cube("datav:/com/datav-engine-radar/0.0.6/shaders/radar.vert.glsl",[],function(a){return a.exports="#define GLSLIFY 1\n#include <logdepthbuf_pars_vertex>\n\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n  #include <logdepthbuf_vertex>\n}",a.exports});;
Cube("datav:/com/datav-engine-radar/0.0.6/layer",["datav:/npm/eventemitter3/3.0.0"],function(a,b,c){const d=c("datav:/npm/eventemitter3/3.0.0");return a.exports=class extends d{constructor(){super(),this.preSceneName="main",this.usingSceneName="main"}addTo(a){return a?void(this.viewer=a,this.Utils=a.Utils,this.controller=a.controller,this.scene=this.getAssignedScene(),this.viewer.on("projChanged",this.updatePostions.bind(this))):console.log("Layer needs viewer layer")}getProjPos(a,b,c){return this.viewer&&this.viewer.Projection([a,b,c])}updatePostions(){}getAssignedScene(){const a=this.options;return a.isSceneGroup&&a.sceneName?a.sceneName?this.controller.getScene(a.sceneName)?this.controller.getScene(a.sceneName):this.controller.createScene(a.sceneName):void 0:this.controller.getScene("main")}toggleScene(a,b,c){this.controller.switchScene(a,b,c).then(()=>{this.preSceneName=b,this.usingSceneName=c})}updateOptions(){}},a.exports});;
Cube("datav:/com/datav-engine-radar/0.0.6",[],function(a,b,c){let d=null,e=null;const f=c("datav:/com/datav-engine-radar/0.0.6/layer"),g=c("datav:/com/datav-engine-radar/0.0.6/shaders/radar.vert.glsl"),h=c("datav:/com/datav-engine-radar/0.0.6/shaders/radar.frag.glsl");return a.exports=class extends f{constructor(a,b){super(),this.options=Object.assign({isSceneGroup:!1,sceneName:"",color:"#ff3300",scaleFactor:1,speed:1e-3,light:1,yOffset:0,visible:!0},b||{})}addTo(a){return a?void(super.addTo(a),d=a.three,e=a.Utils,this.animation=this.animation.bind(this),this.viewer.on("animationFrame",this.animation)):console.log("Cruiser Marker layer needs viewer layer")}createMesh(a){let b=new d.Group,c=this.createRadar(a);return b.add(c),b}createRadar(a){let b=new d.Group;b.name="radarMesh";let c=e.Chroma(this.options.color).gl();this.radarTexture=new d.TextureLoader().setCrossOrigin("*").load(this.options.radarBackground);let f=new d.PlaneBufferGeometry(10,10);this.materialRadar=new d.ShaderMaterial({uniforms:{uTexture:{value:this.radarTexture},uColor:{value:new d.Vector3(c[0],c[1],c[2])},uAngle:{value:6.2831852},uLight:{value:this.options.light},uTimeCounter:{value:1e4}},vertexShader:g,fragmentShader:h,transparent:!0,opacity:1,blending:d.AdditiveBlending,depthWrite:!1,side:d.DoubleSide}),this.radarTexture.minFilter=d.LinearMipMapLinearFilter,this.radarTexture.anisotropy=16,this.materialRadar.needsUpdate=!0;let i=new d.Mesh(f,this.materialRadar);return i.scale.set(this.options.scaleFactor,this.options.scaleFactor,this.options.scaleFactor),i.rotation.x=-Math.PI/2,i.renderOrder=5e3,a.forEach((a)=>{let c=i.clone();c.position.set(a.x,this.options.yOffset,a.z),b.add(c)}),b}projectData(a){return a.map((a)=>{let b=this.getProjPos(a.x,a.y,a.z);return{x:b[0],y:b[1],z:b[2]}})}setData(a){if(!a||!Array.isArray(a))return console.log("error: no data for animation marker component.");if(this.dispose(),!a.length)return console.log("error: wrong data format for animation marker component.");this._data=a;let b=this.projectData(a);this.componentMesh=this.createMesh(b),this.componentMesh.position.y=this.options.yOffset,this.scene.add(this.componentMesh),this.checkVisible()}animation(){this.componentMesh&&(this.materialRadar.uniforms.uTimeCounter.value=this.updateUniformCounters(this.materialRadar.uniforms.uTimeCounter.value,1e4,0,0.03,0),this.materialRadar.uniforms.uAngle.value=this.updateUniformCounters(this.materialRadar.uniforms.uAngle.value,6.2831852,0,this.options.speed,0))}updateUniformCounters(a,b,c,d,e){let f=a;return 1==e?(f+=d,f>=c&&(f=b)):(f-=d,f<=c&&(f=b)),f}updatePostions(){this.dispose(),this.setData(this._data)}updateYoffset(){this.componentMesh.position.y=this.options.yOffset}updateLight(){this.materialRadar.uniforms.uLight.value=this.options.light}updateMeshScale(){this.dispose(),this.setData(this._data)}updateMeshItemVisible(){this.circleMesh.visible=this.options.displayCircle}checkVisible(){let a=this.options;a.visible?this.show():this.hide()}hide(){this.options.visible=!1,this.componentMesh&&(this.componentMesh.visible=!1)}show(){this.options.visible=!0,this.componentMesh&&(this.componentMesh.visible=!0)}updateOptions(a){const b=this.Utils.deepClone(this.options);this.options=this.Utils.mergeOptions(this.options,a||{}),this.Utils.easyDiff(b.sceneName,a.sceneName)||(this.scene=this.getAssignedScene(),this.toggleScene(this.componentMesh,this.usingSceneName,a.sceneName)),this.updateMeshScale(),this.updateYoffset(),this.updateLight(),this.checkVisible()}disposeNode(a){a.traverse((a)=>{if(a.geometry&&a.geometry.dispose(),a.material){let b;a.material instanceof d.MeshFaceMaterial||a.material instanceof d.MultiMaterial?b=a.material.materials:a.material instanceof Array&&(b=a.material),b?b.forEach((a)=>{a.map&&a.map.dispose(),a.lightMap&&a.lightMap.dispose(),a.bumpMap&&a.bumpMap.dispose(),a.normalMap&&a.normalMap.dispose(),a.specularMap&&a.specularMap.dispose(),a.envMap&&a.envMap.dispose(),a.dispose()}):(a.material.map&&a.material.map.dispose(),a.material.lightMap&&a.material.lightMap.dispose(),a.material.bumpMap&&a.material.bumpMap.dispose(),a.material.normalMap&&a.material.normalMap.dispose(),a.material.specularMap&&a.material.specularMap.dispose(),a.material.envMap&&a.material.envMap.dispose(),a.material.dispose())}})}disposeComponentMeshes(){this.componentMesh=null}dispose(){this.componentMesh&&(this.scene.remove(this.componentMesh),this.disposeNode(this.componentMesh))}remove(){this.dispose(),this._data=null,this.radarTexture=null}},a.exports});