// env=undefined => env=publish 
Cube("datav:/com/datav-engine-circle-dual/0.0.6/shaders/circle.frag.glsl",[],function(a){return a.exports="#ifdef GL_ES\n  precision highp float;\n#define GLSLIFY 1\n#endif\n\n#include <logdepthbuf_pars_fragment>\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform float uR1;\nuniform float uR2;\nuniform float uLight;\n// uniform float uThickness;\nvarying vec2 vUv;\n\n// float ring(vec2 st);\nfloat circle(vec2 st, float r);\n\nvoid main() {\n  #include <logdepthbuf_fragment>\n\n  vec2 coord = vUv - 0.5;\n\n  vec4 colorMasker1 = vec4(uColor1, 1.0);\n  vec4 colorMasker2 = vec4(uColor2, 1.0);\n\n  vec4 color1 = vec4(1.0 - circle(coord, uR1));\n  vec4 color2 = vec4(1.0 - circle(coord, uR2));\n\n  color1 *= colorMasker1;\n  color2 *= colorMasker2;\n\n  gl_FragColor = color1 + color2;\n  gl_FragColor *= uLight;\n\n  #include <premultiplied_alpha_fragment>\n}\n\nfloat circle(vec2 st, float r) {\n  //r should be limited between 0.1 ~ 0.4\n  float dr = 1.0;\n\n  float d = length(st);\n  // float c = smoothstep(r, r - (dr/20.0), d) + smoothstep(r, r + (dr/20.0), d);\n  float c = smoothstep(r, r - 0.05, d) + smoothstep(r, r + 0.05, d);\n\n  return c;\n}",a.exports});;
Cube("datav:/com/datav-engine-circle-dual/0.0.6/shaders/circle.vert.glsl",[],function(a){return a.exports="#define GLSLIFY 1\n#include <logdepthbuf_pars_vertex>\n\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n  #include <logdepthbuf_vertex>\n}",a.exports});;
Cube("datav:/com/datav-engine-circle-dual/0.0.6/layer",["datav:/npm/eventemitter3/3.0.0"],function(a,b,c){const d=c("datav:/npm/eventemitter3/3.0.0");return a.exports=class extends d{constructor(){super(),this.preSceneName="main",this.usingSceneName="main"}addTo(a){return a?void(this.viewer=a,this.Utils=a.Utils,this.controller=a.controller,this.scene=this.getAssignedScene(),this.viewer.on("projChanged",this.updatePostions.bind(this))):console.log("Layer needs viewer layer")}getProjPos(a,b,c){return this.viewer&&this.viewer.Projection([a,b,c])}updatePostions(){}getAssignedScene(){const a=this.options;return a.isSceneGroup&&a.sceneName?a.sceneName?this.controller.getScene(a.sceneName)?this.controller.getScene(a.sceneName):this.controller.createScene(a.sceneName):void 0:this.controller.getScene("main")}toggleScene(a,b,c){this.controller.switchScene(a,b,c).then(()=>{this.preSceneName=b,this.usingSceneName=c})}updateOptions(){}},a.exports});;
Cube("datav:/com/datav-engine-circle-dual/0.0.6",[],function(a,b,c){let d=null,e=null;const f=c("datav:/com/datav-engine-circle-dual/0.0.6/layer"),g=c("datav:/com/datav-engine-circle-dual/0.0.6/shaders/circle.vert.glsl"),h=c("datav:/com/datav-engine-circle-dual/0.0.6/shaders/circle.frag.glsl");return a.exports=class extends f{constructor(a,b){super(),this.options=Object.assign({isSceneGroup:!1,sceneName:"",color1:"#ff9900",color2:"#0099ff",scaleFactor:1,light:1.5,thickness:20,yOffset:0,visible:!0},b||{})}addTo(a){return a?void(super.addTo(a),d=a.three,e=a.Utils,this.animation=this.animation.bind(this),this.viewer.on("animationFrame",this.animation)):console.log("Cruiser Marker layer needs viewer layer")}createMesh(a){let b=new d.Group,c=this.createCircle(a);return b.add(c),b}createCircle(a){let b=new d.Group;b.name="circleMesh";let c=this.extentData(a),f=e.Chroma(this.options.color1).gl(),g=e.Chroma(this.options.color2).gl();return a.forEach((a)=>{let d=0.4,e=0.4,h=Math.sqrt(a.s/c[1]),i=Math.sqrt(a.s/c[1]);a.s>a.t?(d=0.4*h,e=0.2*i):a.s<a.t&&(d=0.2*h,e=0.4*i);let j=this.createCircleItem(c,f,g,d,e);j.position.set(a.x,this.options.yOffset,a.z),b.add(j)}),b}createCircleItem(a,b,c,e,f){let i=new d.PlaneBufferGeometry(10,10),j=new d.ShaderMaterial({uniforms:{uColor1:{value:new d.Vector3(b[0],b[1],b[2])},uColor2:{value:new d.Vector3(c[0],c[1],c[2])},uR1:{value:e},uR2:{value:f},uLight:{value:this.options.light},uTimeCounter:{value:1e4}},vertexShader:g,fragmentShader:h,transparent:!0,opacity:1,blending:d.AdditiveBlending,depthWrite:!1,side:d.DoubleSide}),k=new d.Mesh(i,j);return k.scale.set(this.options.scaleFactor,this.options.scaleFactor,this.options.scaleFactor),k.rotation.x=-Math.PI/2,k.renderOrder=6100,k}projectData(a){return a.map((a)=>{let b=this.getProjPos(a.x,a.y,a.z);return{x:b[0],y:b[1],z:b[2],s:a.s,t:a.t}})}extentData(a){let b=[],c=[];return a.forEach((a)=>{c.push(a.s),c.push(a.t)}),b.push(Math.min.apply(null,c),Math.max.apply(null,c)),b}calculateRadius(a,b){let c=(a-b[0])/(b[1]-b[0]);return 0.1+0.3*c}setData(a){if(!a||!Array.isArray(a))return console.log("error: no data for animation marker component.");if(this.dispose(),!a.length)return console.log("error: wrong data format for animation marker component.");this._data=a;let b=this.projectData(a);this.componentMesh=this.createMesh(b),this.componentMesh.position.y=this.options.yOffset,this.scene.add(this.componentMesh),this.checkVisible()}animation(){this.componentMesh}updateUniformCounters(a,b,c,d,e){let f=a;return 1==e?(f+=d,f>=c&&(f=b)):(f-=d,f<=c&&(f=b)),f}updatePostions(){this.dispose(),this.setData(this._data)}updateYoffset(){this.componentMesh.position.y=this.options.yOffset}updateLight(){this.dispose(),this.setData(this._data)}updateMeshScale(){this.dispose(),this.setData(this._data)}checkVisible(){let a=this.options;a.visible?this.show():this.hide()}hide(){this.options.visible=!1,this.componentMesh&&(this.componentMesh.visible=!1)}show(){this.options.visible=!0,this.componentMesh&&(this.componentMesh.visible=!0)}updateOptions(a){const b=this.Utils.deepClone(this.options);this.options=this.Utils.mergeOptions(this.options,a||{}),this.Utils.easyDiff(b.sceneName,a.sceneName)||(this.scene=this.getAssignedScene(),this.toggleScene(this.componentMesh,this.usingSceneName,a.sceneName)),this.updateMeshScale(),this.updateYoffset(),this.updateLight(),this.checkVisible()}disposeNode(a){a.traverse((a)=>{if(a.geometry&&a.geometry.dispose(),a.material){let b;a.material instanceof d.MeshFaceMaterial||a.material instanceof d.MultiMaterial?b=a.material.materials:a.material instanceof Array&&(b=a.material),b?b.forEach((a)=>{a.map&&a.map.dispose(),a.lightMap&&a.lightMap.dispose(),a.bumpMap&&a.bumpMap.dispose(),a.normalMap&&a.normalMap.dispose(),a.specularMap&&a.specularMap.dispose(),a.envMap&&a.envMap.dispose(),a.dispose()}):(a.material.map&&a.material.map.dispose(),a.material.lightMap&&a.material.lightMap.dispose(),a.material.bumpMap&&a.material.bumpMap.dispose(),a.material.normalMap&&a.material.normalMap.dispose(),a.material.specularMap&&a.material.specularMap.dispose(),a.material.envMap&&a.material.envMap.dispose(),a.material.dispose())}})}disposeComponentMeshes(){this.componentMesh=null}dispose(){this.componentMesh&&(this.scene.remove(this.componentMesh),this.disposeNode(this.componentMesh),this.disposeComponentMeshes())}remove(){this.dispose(),this._data=null}},a.exports});