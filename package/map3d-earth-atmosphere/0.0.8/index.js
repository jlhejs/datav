// env=undefined => env=publish 
Cube("datav:/com/map3d-earth-atmosphere/0.0.8/shader/frag.glsl",[],function(a){return a.exports="#define GLSLIFY 1\nvarying vec3 vNormal;\nuniform vec3 uColor;\nuniform float intensity;\nuniform float maxOpacity;\n\nvoid main() {\n  float k = pow(0.51 - dot( vNormal, vec3(0, 0, 1.0)), intensity);\n  gl_FragColor = vec4(uColor * k * k, maxOpacity * 0.5) * k;\n}",a.exports});;
Cube("datav:/com/map3d-earth-atmosphere/0.0.8/shader/vert.glsl",[],function(a){return a.exports="#define GLSLIFY 1\nvarying vec3 vNormal;\n\nattribute vec3 plane_position;\nattribute vec3 sphere_position;\nattribute vec3 sphere_normal;\nattribute vec3 plane_normal;\n\nuniform float u_proj_type;\nuniform float u_ease_index;\n\nvec3 real_position() {\n  if(u_proj_type == 0.){\n    return mix(plane_position, sphere_position, u_ease_index);\n  } else if(u_proj_type == 1.){\n     return mix(sphere_position, plane_position, u_ease_index);\n  } else {\n    return vec3(0);\n  }\n}\n\nvec3 real_normal() {\n  if(u_proj_type == 0.){\n    return mix(plane_normal, sphere_normal, u_ease_index);\n  } else if(u_proj_type == 1.){\n     return mix(sphere_normal, plane_normal, u_ease_index);\n  } else {\n    return vec3(0);\n  }\n}\n\nvoid main() {\n  vNormal = normalize( normalMatrix * real_normal() );\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( real_position(), 1.0 );\n}",a.exports});;
Cube("datav:/com/map3d-earth-atmosphere/0.0.8",["datav:/npm/eventemitter3/2.0.3"],function(a,b,d){let e=null,f=null;const c=d("datav:/npm/eventemitter3/2.0.3");return a.exports=class extends c{constructor(a,b){super(),this.options=Object.assign({visible:!0,atmosphereColor:"#cccccc",atmosphereOpacity:1,atmosphereIntensity:2,atmosphereScale:1.2},b||{})}addTo(a){return a?void(this.map=a,e=a.THREE,f=a.Utils,this.scene=a.scene,this.init(),this.map.on("projChanged",this.updatePostions.bind(this))):console.log("Atmosphere layer needs map layer")}init(){let a=this.options,b=a.atmosphereScale,g=a.atmosphereColor,h=a.atmosphereOpacity,i=a.atmosphereIntensity,j=f.Chroma(g).gl();this.materialAtmosphere=new e.ShaderMaterial({uniforms:{intensity:{type:"f",value:i},maxOpacity:{type:"f",value:h},uColor:{type:"vec3",value:new e.Vector3(j[0],j[1],j[2])},u_ease_index:{value:1},u_proj_type:{value:this.map.projType}},vertexShader:d("datav:/com/map3d-earth-atmosphere/0.0.8/shader/vert.glsl"),fragmentShader:d("datav:/com/map3d-earth-atmosphere/0.0.8/shader/frag.glsl"),side:e.BackSide,transparent:!0}),this.createSphereGeometry(64,64,200);let c=this.geometryAtmosphere=new e.BufferGeometry;c.setIndex(new e.BufferAttribute(this.indexs,1)),c.addAttribute("uv",new e.BufferAttribute(this.uvs,2).setDynamic(!0)),c.addAttribute("sphere_normal",new e.BufferAttribute(this.sphereNormals,3).setDynamic(!0)),c.addAttribute("plane_normal",new e.BufferAttribute(this.planeNormals,3).setDynamic(!0)),c.addAttribute("sphere_position",new e.BufferAttribute(this.spherePositionArray,3).setDynamic(!0)),c.addAttribute("plane_position",new e.BufferAttribute(this.planePositionArray,3).setDynamic(!0));let k=this.meshAtomesphere=new e.Mesh(this.geometryAtmosphere,this.materialAtmosphere);k.scale.set(b,b,b),k.renderOrder=3,this.scene.add(k),this.checkVisible()}createSphereGeometry(a,b,c){const d=Math.floor(a),g=Math.floor(b),h=new e.Vector3,k=[],l=[],m=[],n=[],o=[],p=[];let q=0;const r=[];for(let e,l=0;l<=g;l++){e=[];for(let a=0;a<=d;a++){const b=-90+a*(180/g),i=-180+l*(360/d),j=f.ll2sphere(i,b,c);o.push(j.x,j.y,j.z),h.set(j.x,j.y,j.z).normalize(),m.push(h.x,h.y,h.z);const r=f.ll2plane(i,b,c);p.push(r.x,r.y,r.z),h.set(r.x,r.y,r.z).normalize(),n.push(h.x,h.y,h.z),k.push(l/d,a/g),e.push(q++)}r.push(e)}for(let e=0;e<g;e++)for(let f=0;f<d;f++){let g=r[e][f+1],a=r[e][f],b=r[e+1][f],c=r[e+1][f+1];l.push(g,a,c),l.push(a,b,c)}this.uvs=new Float32Array(k),this.indexs=new Uint16Array(l),this.sphereNormals=new Float32Array(m),this.planeNormals=new Float32Array(n),this.planePositionArray=new Float32Array(p),this.spherePositionArray=new Float32Array(o)}checkVisible(){let a=this.options;a.visible?this.show():this.hide()}hide(){this.options.visible=!1,this.meshAtomesphere&&(this.meshAtomesphere.visible=!1)}show(){this.options.visible=!0,this.meshAtomesphere&&(this.meshAtomesphere.visible=!0)}updatePostions(a){const{projType:b,index:c}=a;this.materialAtmosphere.uniforms.u_ease_index.value=c,this.materialAtmosphere.uniforms.u_proj_type.value=b}updateAtmosphere(){let a=this.options,b=a.atmosphereScale,d=a.atmosphereColor,g=a.atmosphereOpacity,h=a.atmosphereIntensity,i=f.Chroma(d).gl();this.materialAtmosphere.uniforms.intensity.value=h,this.materialAtmosphere.uniforms.maxOpacity.value=g,this.materialAtmosphere.uniforms.uColor.value=new e.Vector3(i[0],i[1],i[2]),this.materialAtmosphere.needsUpdate=!0,this.meshAtomesphere.scale.set(b,b,b)}updateOptions(a){this.options=f.mergeOptions(this.options,a||{}),this.updateAtmosphere(),this.checkVisible()}remove(){this.map.off("projChanged",this.updatePostions),this.scene.remove(this.meshAtomesphere),this.meshAtomesphere&&this.meshAtomesphere.dispose&&this.meshAtomesphere.dispose(),this.geometryAtmosphere&&this.geometryAtmosphere.dispose&&this.geometryAtmosphere.dispose(),this.materialAtmosphere&&this.materialAtmosphere.dispose&&this.materialAtmosphere.dispose(),this.meshAtomesphere=null,this.geometryAtmosphere=null,this.materialAtmosphere=null}},a.exports});