// env=undefined => env=publish 
Cube("datav:/com/datav-engine-geofence/0.0.9/extrude.js",["datav:/npm/earcut/2.1.3"],function(a,b,c){const d=c("datav:/npm/earcut/2.1.3");return a.exports=function(a,b){b=Object.assign({height:1,base:0,project:(a)=>[a[0]||0,a[1]||0,a[2]||0],closed:!1},b);let c=d.flatten([a]),e=c.vertices,f=e.length/c.dimensions,g=[],h=[];for(let d=0;d<f;d++)g.push(e[d*c.dimensions+0]),h.push(e[d*c.dimensions+1]);let j=[Math.min.apply(null,g),Math.min.apply(null,h),Math.max.apply(null,g),Math.max.apply(null,h)],k=[],l=[],m=[],n=[],o=[],q=d(c.vertices,c.holes,c.dimensions),r=e.length/c.dimensions;if(b.height===b.base){let a=j[2]-j[0],d=j[3]-j[1];e.forEach((f,g)=>{if(0===g%c.dimensions){let c=b.project([e[g],e[g+1],b.height]);m.push((e[g]-j[0])/a,(e[g+1]-j[1])/d),k.push(c[0],c[1],c[2]),n.push(c[1]),o.push(b.color[0],b.color[1],b.color[2],b.color[3])}}),l=q}else{let a=[],d=[],f=[],g=[];e.forEach((h,j)=>{if(0===j%c.dimensions){let c=b.project([e[j],e[j+1],b.height]);k.push(c[0],c[1],c[2]),o.push(b.color[0],b.color[1],b.color[2],b.color[3]),m.push(0===j%2?0:1,1),n.push(b.height-b.base),a.push(c[0],b.base,c[2]),g.push(b.color[0],b.color[1],b.color[2],b.color[3]),d.push(0===j%2?0:1,0),f.push(0)}}),[].push.apply(k,a),[].push.apply(o,g),[].push.apply(m,d),[].push.apply(n,f);for(let a=0;a<r;a++)a===r-1?l.push(a+r,r,a,0,a,r):l.push(a+r,a+r+1,a,a+1,a,a+r+1);[].push.apply(l,q),b.closed&&q.forEach((a,b)=>{0===b%3&&l.push(q[b+0]+r,q[b+1]+r,q[b+2]+r)})}return{positions:k,indices:l,uvs:m,heights:n,colors:o}},a.exports});;
Cube("datav:/com/datav-engine-geofence/0.0.9/shader/vert.glsl",[],function(a){return a.exports="#define GLSLIFY 1\nvarying vec2 vUv;\n#include <logdepthbuf_pars_vertex>\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  #include <logdepthbuf_vertex>\n}",a.exports});;
Cube("datav:/com/datav-engine-geofence/0.0.9/shader/frag.glsl",[],function(a){return a.exports="#define GLSLIFY 1\nuniform vec4 u_color;\n#include <logdepthbuf_pars_fragment>\n\nvarying vec2 vUv;\nvoid main() {\n  #include <logdepthbuf_fragment>\n  float opacity = pow(1. - vUv.y, 2.);\n  gl_FragColor = vec4(u_color.rgb, opacity * u_color.a);\n   #include <premultiplied_alpha_fragment>\n}",a.exports});;
Cube("datav:/com/datav-engine-geofence/0.0.9/extrude_polygon",[],function(a,b,c){const d=c("datav:/com/datav-engine-geofence/0.0.9/extrude.js");return a.exports=function(a,b){let c={closed:!1,project:(a)=>[a[0]||0,a[1]||0,a[2]||0],getHeight:function(a){return a.height||0},getBase:function(){return 0},getKey:function(a){return a.id||Math.floor(1e3*Math.random())},getVertexColor:function(a){return a.color||[1,0,0,1]}};Object.assign(c,b);let e=[],f=[],g=[],h=[],i=[],j={};for(let k=0,l=a.length;k<l;k++){let b=a[k],l=c.getHeight(b),m=c.getBase(),n=c.project;coordinates=b;let o=e.length/3,p=e.length/3,q=d(coordinates,{height:l,base:m,project:n,color:c.getVertexColor(b)});[].push.apply(e,q.positions),[].push.apply(h,q.uvs),[].push.apply(i,q.heights),[].push.apply(g,q.colors);let r=q.indices,s=r.map(function(a){return a+p});[].push.apply(f,s);let t=e.length/3,u=c.getKey(b);u&&(j[u]=[o,t,k])}let k={positions:new Float32Array(e),indices:new Int32Array(f),uvs:new Float32Array(h),heights:new Float32Array(i),keyIndex:j,colors:new Float32Array(g)};return k},a.exports});;
Cube("datav:/com/datav-engine-geofence/0.0.9/layer.js",["datav:/npm/eventemitter3/3.0.0"],function(a,b,c){const d=c("datav:/npm/eventemitter3/3.0.0");return a.exports=class extends d{constructor(){super(),this.preSceneName="main",this.usingSceneName="main"}addTo(a){return a?void(this.viewer=a,this.Utils=a.Utils,this.controller=a.controller,this.scene=this.getAssignedScene(),this.viewer.on("projChanged",this.updatePostions.bind(this))):console.log("Layer needs viewer layer")}getProjPos(a,b,c){return this.viewer&&this.viewer.Projection([a,b,c])}updatePostions(){}getAssignedScene(){const a=this.options;return a.isSceneGroup&&a.sceneName?a.sceneName?this.controller.getScene(a.sceneName)?this.controller.getScene(a.sceneName):this.controller.createScene(a.sceneName):void 0:this.controller.getScene("main")}toggleScene(a,b,c){this.controller.switchScene(a,b,c).then(()=>{this.preSceneName=b,this.usingSceneName=c})}show(){}hide(){}updateOptions(){}},a.exports});;
Cube("datav:/com/datav-engine-geofence/0.0.9",[],function(a,b,d){let e=null,f=null;const c=d("datav:/com/datav-engine-geofence/0.0.9/layer.js"),g=d("datav:/com/datav-engine-geofence/0.0.9/extrude_polygon");return a.exports=class extends c{constructor(a,b){super(),this.options=Object.assign({visibility:!0,geofenceHeight:1,offsetHeight:0},b||{})}addTo(a){super.addTo(a),e=a.three,f=a.Utils}initMaterial(){const a=f.Chroma(this.options.color).gl();return new e.ShaderMaterial({uniforms:{u_color:{value:new e.Vector4(a[0],a[1],a[2],a[3])}},vertexShader:d("datav:/com/datav-engine-geofence/0.0.9/shader/vert.glsl"),fragmentShader:d("datav:/com/datav-engine-geofence/0.0.9/shader/frag.glsl"),blending:e.AdditiveBlending,side:e.DoubleSide,transparent:!0,depthWrite:!1,depthTest:!0})}setData(a){if(!a||!Array.isArray(a))return console.log("geofence layer no data");if(this.dispose(),!a.length)return console.log("geofence layer no data");const b=this.options;this.data=a;const c=g(a,{getHeight:function(){return b.geofenceHeight},getBase:function(){return b.offsetHeight},project:this.viewer.Projection}),d=this.geometry=new e.BufferGeometry;d.setIndex(new e.BufferAttribute(new Uint32Array(c.indices),1)),d.addAttribute("position",new e.BufferAttribute(new Float32Array(c.positions),3).setDynamic(!0)),d.addAttribute("uv",new e.BufferAttribute(new Float32Array(c.uvs),2).setDynamic(!0)),d.computeBoundingSphere(),d.computeVertexNormals(),d.normalizeNormals(),d.computeBoundingBox();const f=this.mesh=new e.Mesh(d,this.initMaterial());f.frustumCulled=!1,f.renderOrder=5e3,this.scene.add(f),this.checkVisible()}checkVisible(){let a=this.options;a.visibility?this.show():this.hide()}show(){this.options.visibility=!0,this.mesh&&(this.mesh.visible=!0)}hide(){this.options.visibility=!1,this.mesh&&(this.mesh.visible=!1)}updateMaterial(){const a=f.Chroma(this.options.color).gl();this.mesh&&(this.mesh.material.uniforms.u_color.value=new e.Vector4(a[0],a[1],a[2],a[3]),this.mesh.visible=this.options.visibility)}updateOptions(a){const b=f.deepClone(this.options);this.options=f.mergeOptions(this.options,a||{}),f.easyDiff(b.offsetHeight,a.offsetHeight)&&f.easyDiff(b.visibility,a.visibility)||this.updateMaterial(),f.easyDiff(b.color,a.color)&&f.easyDiff(b.geofenceHeight,a.geofenceHeight)||this.setData(this.data),this.checkVisible(),f.easyDiff(b.sceneName,a.sceneName)||(this.scene=this.getAssignedScene(),this.toggleScene(this.mesh,this.usingSceneName,a.sceneName))}dispose(){this.scene.remove(this.mesh),this.mesh&&this.mesh.dispose&&this.mesh.dispose(),this.material&&this.material.dispose&&this.material.dispose(),this.geometry&&this.geometry.dispose&&this.geometry.dispose(),this.mesh=null,this.material=null,this.geometry=null}remove(){this.dispose(),this.data=null}},a.exports});