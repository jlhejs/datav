// env=undefined => env=publish 
Cube("datav:/com/datav-engine-animation-marker/0.0.13/shaders/circle.frag.glsl",[],function(a){return a.exports="#ifdef GL_ES\n  precision highp float;\n#define GLSLIFY 1\n#endif\n\n#include <logdepthbuf_pars_fragment>\n\nuniform float uTimeCounter;\nuniform vec3 uColor;\nvarying vec2 vUv;\n\nfloat calOpacityByPolarDistance(float polarLength, float startPoint);\nfloat calculateHightColor(float uvPosition, float thickness, float intensity);\nfloat tweenBounceOut(float k);\nfloat tweenBounceIn(float k);\nfloat tweenBounceInOut(float k);\n\nvoid main() {\n  #include <logdepthbuf_fragment>\n\n  vec2 polarSt = vec2(atan(vUv.x-0.5, vUv.y-0.5), distance(vUv, vec2(0.5, 0.5)));\n\n  float thickness = 1.0;\n  float intensity = 1.1;\n  float transparentStartUv = 0.1;\n  float col = 15.0;\n  float uvY = polarSt.y * col;\n\n  float fractUvY = fract(uvY + uTimeCounter);\n  float centerY = 0.5;\n  float barColor = calculateHightColor(fractUvY, thickness, intensity);\n\n  if(polarSt.y <= 0.5) {\n    barColor *= calOpacityByPolarDistance(polarSt.y, transparentStartUv);\n  } else {\n    barColor = 0.0;\n  }\n\n  gl_FragColor = vec4(barColor);\n\n  // vec4 colorMask = vec4(0.7, 1.0, 2.1, 1.0);\n  vec4 colorMask = vec4(uColor, 1.0);\n  gl_FragColor *= colorMask;\n\n  #include <premultiplied_alpha_fragment>\n}\n\nfloat calculateHightColor(float uvPosition, float thickness, float intensity) {\n  float e = (0.5 - abs(uvPosition - 0.5)) / 0.5;\n  return pow(e * thickness, intensity);\n}\n\nfloat calOpacityByPolarDistance(float polarLength, float startPoint) {\n  float totalPolarLength = 0.5;\n  float opacity = 1.0;\n  if(polarLength > startPoint) {\n    float distancePercent = (totalPolarLength - polarLength) / (totalPolarLength - startPoint);\n    return pow(distancePercent, 2.0);\n  } else {\n    return 1.0;\n  }\n}\n\nfloat tweenBounceOut(float k) {\n  if (k < (1.0 / 2.75)) {\n    return 7.5625 * k * k;\n  } else if (k < (2.0 / 2.75)) {\n    return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n  } else if (k < (2.5 / 2.75)) {\n    return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n  } else {\n    return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n  }\n}\n\nfloat tweenBounceIn(float k) {\n  return 1.0 - tweenBounceOut(1.0 - k);\n}\n\nfloat tweenBounceInOut(float k) {\n  if (k < 0.5) {\n    return tweenBounceIn(k * 2.0) * 0.5;\n  }\n\n  return tweenBounceOut(k * 2.0 - 1.0) * 0.5 + 0.5;\n}",a.exports});;
Cube("datav:/com/datav-engine-animation-marker/0.0.13/shaders/matrix.frag.glsl",[],function(a){return a.exports="#ifdef GL_ES\n  precision highp float;\n#define GLSLIFY 1\n#endif\n\n#include <logdepthbuf_pars_fragment>\n\nuniform float uTimeCounter;\nuniform float uCounter;\nuniform vec3 uColor;\nvarying vec2 vUv;\n\nfloat CubicEaseOut(float t, float b, float c, float d);\nfloat calculateHightColor(float uvPosition, float thickness, float intensity);\nfloat calculateOpacityByTime(float uUvHeightLimitCounter, float startTransparentCounter);\nfloat calculateOpacityByUvLimit(float uvHeight, float uvHeightLimitCounter, float startTransparentPercent);\nfloat enhanceColorByUv(float uvParam, float startEnhancePercent);\nfloat calculateGridColor(float columnNumber, vec2 vUv);\nfloat calculateRadiusOpacity(vec2 vUv, float startTransparentPercent);\nfloat calculateEaseOpacityByTime(float uCounter, float startPoint, float endPoint);\n\nvoid main() {\n  #include <logdepthbuf_fragment>\n\n  float col = 5.0;\n  float thickness = 0.9;\n  float intensity = 2.5;\n  float transparentStartUv = 0.7;\n  float transparentStartTime = 0.8;\n  float uvY = vUv.y * col;\n\n  float newTimeCounter = CubicEaseOut(uTimeCounter, 0., 1., 1.);\n  // float fractUvY = fract(uvY + newTimeCounter);\n  float fractUvY = fract(uvY + uTimeCounter);\n  float centerY = 0.5;\n  float barColor = calculateHightColor(fractUvY, thickness, intensity);\n\n  // float curvedHeightLimitedCounter = CubicEaseOut(uUvHeightLimitCounter, 0., 1., 1.);\n  // float opacityByUvLimit = calculateOpacityByUvLimit(vUv.y, curvedHeightLimitedCounter, transparentStartUv);\n  // float opacityByTime = calculateOpacityByTime(curvedHeightLimitedCounter, transparentStartTime);\n  // float opacityByUvLimit = calculateOpacityByUvLimit(vUv.y, uUvHeightLimitCounter, transparentStartUv);\n  // float opacityByTime = calculateOpacityByTime(uUvHeightLimitCounter, transparentStartTime);\n  // float enhancedColor = enhanceColorByUv(vUv.y, 0.5);\n\n  // gl_FragColor = vec4(barColor) * opacityByUvLimit * opacityByTime;\n  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n  gl_FragColor *= calculateGridColor(col, vUv);\n  gl_FragColor *= calculateRadiusOpacity(vUv, 0.4);\n  gl_FragColor *= calculateEaseOpacityByTime(uCounter, 0.4, 0.6);\n\n  // vec4 colorMask = vec4(0.3, 0.6, 0.8, 1.0);\n  vec4 colorMask = vec4(uColor, 1.0);\n  gl_FragColor *= colorMask;\n\n  #include <premultiplied_alpha_fragment>\n}\n\nfloat CubicEaseOut(float t, float b, float c, float d) {\n  return c * ((t = t / d - 1.) * t * t + 1.) + b;\n}\n\n//calculate circle opacity\nfloat calculateRadiusOpacity(vec2 vUv, float startTransparentPercent) {\n  vec2 polarSt = vec2(atan(vUv.x-0.5, vUv.y-0.5), distance(vUv, vec2(0.5, 0.5)));\n\n  if(polarSt.y <= startTransparentPercent) {\n    return 1.0;\n  } else {\n    //1.4142 stand for sqrt(2)\n    float distance = max(0.0, (1.4142/2.0 - polarSt.y) / (1.4142/2.0 - startTransparentPercent));\n    return pow(distance, 5.0);\n  }\n}\n\n//to draw the grid\nfloat calculateGridColor(float columnNumber, vec2 vUv) {\n  vec2 uvMultiplyColumn = vUv * columnNumber;\n  vec2 fractUv = fract(uvMultiplyColumn);\n\n  vec2 grid = abs(fractUv - 0.5);\n  float gridValue = max(grid.x, grid.y);\n  float gridColor = smoothstep(0.4, 0.5, gridValue);\n\n  return gridColor;\n}\n\n//enhance the bottom of fire, to make it feels like hot inside\nfloat enhanceColorByUv(float uvParam, float startEnhancePercent) {\n  if(uvParam <= startEnhancePercent) {\n    float distance = (startEnhancePercent - uvParam) / startEnhancePercent;\n    return max(1.0, pow(distance, 2.0) * 3.0);\n  } else {\n    return 1.0;\n  }\n}\n\n//calculate the easing opacity with counter\nfloat calculateEaseOpacityByTime(float uCounter, float startPoint, float endPoint) {\n  if(uCounter <= startPoint) {\n    return (uCounter / startPoint);\n  } else if(uCounter >= endPoint) {\n    return (1.0 - uCounter) / (1.0 - endPoint);\n  } else {\n    return 1.0;\n  }\n}\n\nfloat calculateOpacityByUvLimit(float uvHeight, float uvHeightLimitCounter, float startTransparentPercent) {\n  if(uvHeight > uvHeightLimitCounter) {\n    return 0.0;\n  } else {\n    float startTransparentPoint = startTransparentPercent * uvHeightLimitCounter;\n    if(uvHeight > startTransparentPoint) {\n      float transparentDistance = (uvHeightLimitCounter - uvHeight) / (uvHeightLimitCounter - startTransparentPoint);\n      return pow(transparentDistance, 1.1);\n    } else {\n      return 1.0;\n    }\n  }\n}\n\nfloat calculateOpacityByTime(float uUvHeightLimitCounter, float startTransparentCounter) {\n  if(uUvHeightLimitCounter <= startTransparentCounter) {\n    return 1.0;\n  } else {\n    return (1.0 - uUvHeightLimitCounter) / (1.0 - startTransparentCounter);\n  }\n}\n\nfloat calculateHightColor(float uvPosition, float thickness, float intensity) {\n  float e = (0.5 - abs(uvPosition - 0.5)) / 0.5;\n  return pow(e * thickness, intensity);\n}",a.exports});;
Cube("datav:/com/datav-engine-animation-marker/0.0.13/shaders/matrix.vert.glsl",[],function(a){return a.exports="#define GLSLIFY 1\n#include <logdepthbuf_pars_vertex>\n\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  \n  #include <logdepthbuf_vertex>\n}",a.exports});;
Cube("datav:/com/datav-engine-animation-marker/0.0.13/shaders/fire.vert.glsl",[],function(a){return a.exports="#define GLSLIFY 1\n#include <logdepthbuf_pars_vertex>\n\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n  #include <logdepthbuf_vertex>\n}",a.exports});;
Cube("datav:/com/datav-engine-animation-marker/0.0.13/shaders/wave.frag.glsl",[],function(a){return a.exports="#ifdef GL_ES\n  precision highp float;\n#define GLSLIFY 1\n#endif\n\n#include <logdepthbuf_pars_fragment>\n\nuniform float uTimeCounter;\nuniform float uUvHeightLimitCounter;\nuniform vec3 uColor;\nvarying vec2 vUv;\n\nfloat CubicEaseOut(float t, float b, float c, float d);\nfloat calculateHightColor(float uvPosition, float thickness, float intensity);\nfloat calculateOpacityByTime(float uUvHeightLimitCounter, float startTransparentCounter);\nfloat calculateOpacityByUvLimit(float uvHeight, float uvHeightLimitCounter, float startTransparentPercent);\n\nvoid main() {\n  #include <logdepthbuf_fragment>\n\n  float col = 9.0;\n  float thickness = 0.9;\n  float intensity = 2.5;\n  float transparentStartUv = 0.5;\n  float transparentStartTime = 0.8;\n  float uvY = vUv.y * col;\n\n  float newTimeCounter = CubicEaseOut(uTimeCounter, 0., 1., 1.);\n  // float fractUvY = fract(uvY + newTimeCounter);\n  float fractUvY = fract(uvY + uTimeCounter);\n  float centerY = 0.5;\n  float barColor = calculateHightColor(fractUvY, thickness, intensity);\n\n  //discard pixel when opacity less 0.01 to avoid postprocessing opacity fault issues\n  if(barColor < 0.005) {\n    discard;\n  }\n\n  float curvedHeightLimitedCounter = CubicEaseOut(uUvHeightLimitCounter, 0., 1., 1.);\n  float opacityByUvLimit = calculateOpacityByUvLimit(vUv.y, curvedHeightLimitedCounter, transparentStartUv);\n  float opacityByTime = calculateOpacityByTime(curvedHeightLimitedCounter, transparentStartTime);\n  // float opacityByUvLimit = calculateOpacityByUvLimit(vUv.y, uUvHeightLimitCounter, transparentStartUv);\n  // float opacityByTime = calculateOpacityByTime(uUvHeightLimitCounter, transparentStartTime);\n\n  gl_FragColor = vec4(barColor) * opacityByUvLimit * opacityByTime;  \n\n  // vec4 colorMask = vec4(0.7, 1.0, 2.1, 1.0);\n  vec4 colorMask = vec4(uColor, 1.0);\n  gl_FragColor *= colorMask;\n\n  #include <premultiplied_alpha_fragment>\n}\n\nfloat CubicEaseOut(float t, float b, float c, float d) {\n  return c * ((t = t / d - 1.) * t * t + 1.) + b;\n}\n\nfloat calculateOpacityByUvLimit(float uvHeight, float uvHeightLimitCounter, float startTransparentPercent) {\n  if(uvHeight > uvHeightLimitCounter) {\n    return 0.0;\n  } else {\n    float startTransparentPoint = startTransparentPercent * uvHeightLimitCounter;\n    if(uvHeight > startTransparentPoint) {\n      float transparentDistance = (uvHeightLimitCounter - uvHeight) / (uvHeightLimitCounter - startTransparentPoint);\n      return pow(transparentDistance, 1.1);\n    } else {\n      return 1.0;\n    }\n  }\n}\n\nfloat calculateOpacityByTime(float uUvHeightLimitCounter, float startTransparentCounter) {\n  if(uUvHeightLimitCounter <= startTransparentCounter) {\n    return 1.0;\n  } else {\n    return (1.0 - uUvHeightLimitCounter) / (1.0 - startTransparentCounter);\n  }\n}\n\nfloat calculateHightColor(float uvPosition, float thickness, float intensity) {\n  float e = (0.5 - abs(uvPosition - 0.5)) / 0.5;\n  return pow(e * thickness, intensity);\n}",a.exports});;
Cube("datav:/com/datav-engine-animation-marker/0.0.13/shaders/fire.frag.glsl",[],function(a){return a.exports="#ifdef GL_ES\n  precision highp float;\n#define GLSLIFY 1\n#endif\n\n#include <logdepthbuf_pars_fragment>\n\nuniform float uTimeCounter;\nuniform float uUvHeightLimitCounter;\nuniform vec3 uColor;\nvarying vec2 vUv;\n\nfloat CubicEaseOut(float t, float b, float c, float d);\nfloat calculateHightColor(float uvPosition, float thickness, float intensity);\nfloat calculateOpacityByTime(float uUvHeightLimitCounter, float startTransparentCounter);\nfloat calculateOpacityByUvLimit(float uvHeight, float uvHeightLimitCounter, float startTransparentPercent);\nfloat enhanceColorByUv(float uvParam, float startEnhancePercent);\n\nvoid main() {\n  #include <logdepthbuf_fragment>\n\n  float col = 9.0;\n  float thickness = 0.9;\n  float intensity = 2.5;\n  float transparentStartUv = 0.5;\n  float transparentStartTime = 0.8;\n  float uvY = vUv.y * col;\n\n  float newTimeCounter = CubicEaseOut(uTimeCounter, 0., 1., 1.);\n  // float fractUvY = fract(uvY + newTimeCounter);\n  float fractUvY = fract(uvY + uTimeCounter);\n  float centerY = 0.5;\n  float barColor = calculateHightColor(fractUvY, thickness, intensity);\n\n  // float curvedHeightLimitedCounter = CubicEaseOut(uUvHeightLimitCounter, 0., 1., 1.);\n  // float opacityByUvLimit = calculateOpacityByUvLimit(vUv.y, curvedHeightLimitedCounter, transparentStartUv);\n  // float opacityByTime = calculateOpacityByTime(curvedHeightLimitedCounter, transparentStartTime);\n  float opacityByUvLimit = calculateOpacityByUvLimit(vUv.y, uUvHeightLimitCounter, transparentStartUv);\n  \n  //discard pixel when opacity less 0.01 to avoid postprocessing opacity fault issues\n  if(opacityByUvLimit < 0.005) {\n    discard;\n  }\n\n  float opacityByTime = calculateOpacityByTime(uUvHeightLimitCounter, transparentStartTime);\n  float enhancedColor = enhanceColorByUv(vUv.y, 0.5);\n\n  // gl_FragColor = vec4(barColor) * opacityByUvLimit * opacityByTime;\n  // gl_FragColor = vec4(0.1, 0.5, 0.9, 1.0);\n  gl_FragColor = vec4(uColor, 1.0);\n  gl_FragColor = gl_FragColor * opacityByUvLimit * opacityByTime * enhancedColor;\n\n  // vec4 colorMask = vec4(0.7, 1.0, 2.1, 1.0);\n  // gl_FragColor *= colorMask;\n  #include <premultiplied_alpha_fragment>\n}\n\nfloat CubicEaseOut(float t, float b, float c, float d) {\n  return c * ((t = t / d - 1.) * t * t + 1.) + b;\n}\n\n//enhance the bottom of fire, to make it feels like hot inside\nfloat enhanceColorByUv(float uvParam, float startEnhancePercent) {\n  if(uvParam <= startEnhancePercent) {\n    float distance = (startEnhancePercent - uvParam) / startEnhancePercent;\n    return max(1.0, pow(distance, 2.0) * 3.0);\n  } else {\n    return 1.0;\n  }\n}\n\nfloat calculateOpacityByUvLimit(float uvHeight, float uvHeightLimitCounter, float startTransparentPercent) {\n  if(uvHeight > uvHeightLimitCounter) {\n    return 0.0;\n  } else {\n    float startTransparentPoint = startTransparentPercent * uvHeightLimitCounter;\n    if(uvHeight > startTransparentPoint) {\n      float transparentDistance = (uvHeightLimitCounter - uvHeight) / (uvHeightLimitCounter - startTransparentPoint);\n      return pow(transparentDistance, 1.1);\n    } else {\n      return 1.0;\n    }\n  }\n}\n\nfloat calculateOpacityByTime(float uUvHeightLimitCounter, float startTransparentCounter) {\n  if(uUvHeightLimitCounter <= startTransparentCounter) {\n    return 1.0;\n  } else {\n    return (1.0 - uUvHeightLimitCounter) / (1.0 - startTransparentCounter);\n  }\n}\n\nfloat calculateHightColor(float uvPosition, float thickness, float intensity) {\n  float e = (0.5 - abs(uvPosition - 0.5)) / 0.5;\n  return pow(e * thickness, intensity);\n}",a.exports});;
Cube("datav:/com/datav-engine-animation-marker/0.0.13/shaders/wave.vert.glsl",[],function(a){return a.exports="#define GLSLIFY 1\n#include <logdepthbuf_pars_vertex>\n\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n  #include <logdepthbuf_vertex>\n}",a.exports});;
Cube("datav:/com/datav-engine-animation-marker/0.0.13/shaders/circle.vert.glsl",[],function(a){return a.exports="#define GLSLIFY 1\n#include <logdepthbuf_pars_vertex>\n\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n  #include <logdepthbuf_vertex>\n}",a.exports});;
Cube("datav:/com/datav-engine-animation-marker/0.0.13/layer",["datav:/npm/eventemitter3/3.0.0"],function(a,b,c){const d=c("datav:/npm/eventemitter3/3.0.0");return a.exports=class extends d{constructor(){super(),this.preSceneName="main",this.usingSceneName="main"}addTo(a){return a?void(this.viewer=a,this.Utils=a.Utils,this.controller=a.controller,this.scene=this.getAssignedScene(),this.viewer.on("projChanged",this.updatePostions.bind(this))):console.log("Layer needs viewer layer")}getProjPos(a,b,c){return this.viewer&&this.viewer.Projection([a,b,c])}updatePostions(){}getAssignedScene(){const a=this.options;return a.isSceneGroup&&a.sceneName?a.sceneName?this.controller.getScene(a.sceneName)?this.controller.getScene(a.sceneName):this.controller.createScene(a.sceneName):void 0:this.controller.getScene("main")}toggleScene(a,b,c){this.controller.switchScene(a,b,c).then(()=>{this.preSceneName=b,this.usingSceneName=c})}updateOptions(){}},a.exports});;
Cube("datav:/com/datav-engine-animation-marker/0.0.13",[],function(a,b,c){let d=null,e=null;const f=c("datav:/com/datav-engine-animation-marker/0.0.13/layer"),g=c("datav:/com/datav-engine-animation-marker/0.0.13/shaders/wave.vert.glsl"),h=c("datav:/com/datav-engine-animation-marker/0.0.13/shaders/wave.frag.glsl"),i=c("datav:/com/datav-engine-animation-marker/0.0.13/shaders/fire.vert.glsl"),j=c("datav:/com/datav-engine-animation-marker/0.0.13/shaders/fire.frag.glsl"),k=c("datav:/com/datav-engine-animation-marker/0.0.13/shaders/matrix.vert.glsl"),l=c("datav:/com/datav-engine-animation-marker/0.0.13/shaders/matrix.frag.glsl"),m=c("datav:/com/datav-engine-animation-marker/0.0.13/shaders/circle.vert.glsl"),n=c("datav:/com/datav-engine-animation-marker/0.0.13/shaders/circle.frag.glsl");return a.exports=class extends f{constructor(a,b){super(),this.options=Object.assign({isSceneGroup:!1,sceneName:"",color:"#0066FF",scaleFactor:1,speedFactor:1,yOffset:0,visible:!0,displayWave:!0,displayFire:!0,displayCircle:!0,displayMatrix:!0},b||{})}addTo(a){return a?void(super.addTo(a),d=a.three,e=a.Utils,this.animation=this.animation.bind(this),this.viewer.on("animationFrame",this.animation)):console.log("AnimationMarker layer needs viewer layer")}createMesh(a){let b=new d.Group;return this.waveMesh=this.createMeshWave(a),this.waveMesh.visible=this.options.displayWave,b.add(this.waveMesh),this.circleMesh=this.createMeshCircle(a),this.circleMesh.visible=this.options.displayCircle,b.add(this.circleMesh),this.fireMesh=this.createMeshFire(a),this.fireMesh.visible=this.options.displayFire,b.add(this.fireMesh),this.matrixMesh=this.createMeshMatrix(a),this.matrixMesh.visible=this.options.displayMatrix,b.add(this.matrixMesh),b}createMeshWave(a){let b=new d.Group;b.name="waveMesh";let c=e.Chroma(this.options.color).gl(),f=new d.CylinderBufferGeometry(7,4,30,4,1,!0);this.materialWave=new d.ShaderMaterial({uniforms:{uColor:{value:new d.Vector3(c[0],c[1],c[2])},uTimeCounter:{value:1e4},uUvHeightLimitCounter:{value:0}},vertexShader:g,fragmentShader:h,transparent:!0,opacity:1,blending:d.AdditiveBlending,depthWrite:!1,side:d.DoubleSide});let i=new d.Mesh(f,this.materialWave);return i.renderOrder=3e3,i.scale.set(this.options.scaleFactor,this.options.scaleFactor,this.options.scaleFactor),a.forEach((a)=>{let c=i.clone();c.position.set(a.x,a.y+15*this.options.scaleFactor,a.z),b.add(c)}),b}createMeshFire(a){let b=new d.Group;b.name="fireMesh";let c=e.Chroma(this.options.color).gl();var f=new d.CylinderBufferGeometry(2,1,14,16,1,!0);this.materialFire=new d.ShaderMaterial({uniforms:{uColor:{value:new d.Vector3(c[0],c[1],c[2])},uTimeCounter:{value:1e4},uUvHeightLimitCounter:{value:0}},vertexShader:i,fragmentShader:j,transparent:!0,opacity:1,blending:d.AdditiveBlending,depthWrite:!1,side:d.DoubleSide});var g=new d.Mesh(f,this.materialFire);return g.renderOrder=3e3,g.scale.set(this.options.scaleFactor,this.options.scaleFactor,this.options.scaleFactor),a.forEach((a)=>{let c=g.clone();c.position.set(a.x,a.y+7*this.options.scaleFactor,a.z),b.add(c)}),b}createMeshCircle(a){let b=new d.Group;b.name="circleMesh";let c=e.Chroma(this.options.color).gl();var f=new d.PlaneBufferGeometry(20,20,1,1);this.materialCircle=new d.ShaderMaterial({uniforms:{uColor:{value:new d.Vector3(c[0],c[1],c[2])},uTimeCounter:{value:1e4},uCounter:{value:0}},vertexShader:m,fragmentShader:n,transparent:!0,opacity:1,blending:d.AdditiveBlending,depthWrite:!1,side:d.DoubleSide});var g=new d.Mesh(f,this.materialCircle);return g.renderOrder=3e3,g.scale.set(this.options.scaleFactor,this.options.scaleFactor,this.options.scaleFactor),g.rotation.x=Math.PI/2,a.forEach((a)=>{let c=g.clone();c.position.set(a.x,a.y,a.z),b.add(c)}),b}createMeshMatrix(a){let b=new d.Group;b.name="matrixMesh";let c=e.Chroma(this.options.color).gl();var f=new d.PlaneBufferGeometry(16,16,1,1);this.materialMatrix=new d.ShaderMaterial({uniforms:{uColor:{value:new d.Vector3(c[0],c[1],c[2])},uTimeCounter:{value:1e4},uCounter:{value:0}},vertexShader:k,fragmentShader:l,transparent:!0,opacity:1,blending:d.AdditiveBlending,depthWrite:!1,side:d.DoubleSide});var g=new d.Mesh(f,this.materialMatrix);return g.renderOrder=3e3,g.scale.set(this.options.scaleFactor,this.options.scaleFactor,this.options.scaleFactor),g.rotation.x=Math.PI/2,a.forEach((a)=>{let c=g.clone();c.position.set(a.x,a.y,a.z),b.add(c)}),b}projectData(a){return a.map((a)=>{let b=this.getProjPos(a.x,a.y,a.z);return a.value||(a.value=0),{x:b[0],y:b[1],z:b[2],value:a.value}})}setData(a){return a&&Array.isArray(a)?(this.dispose(),a.length?void(this._data=a,this.projectedData=this.projectData(a),this.componentMesh=this.createMesh(this.projectedData),this.componentMesh.position.y=this.options.yOffset,this.scene.add(this.componentMesh),this.checkVisible()):console.log("error: wrong data format for animation marker component.")):console.log("error: no data for animation marker component.")}animation(){this.componentMesh&&(this.materialWave.uniforms.uTimeCounter.value=this.updateUniformCounters(this.materialWave.uniforms.uTimeCounter.value,1e4,0,0.03,0),this.materialWave.uniforms.uUvHeightLimitCounter.value=this.updateUniformCounters(this.materialWave.uniforms.uUvHeightLimitCounter.value,0,1,0.02,1),this.materialCircle.uniforms.uTimeCounter.value=this.updateUniformCounters(this.materialCircle.uniforms.uTimeCounter.value,1e4,0,0.03,0),this.materialFire.uniforms.uUvHeightLimitCounter.value=this.updateUniformCounters(this.materialFire.uniforms.uUvHeightLimitCounter.value,0,1,0.02,1),this.materialMatrix.uniforms.uCounter.value=this.updateUniformCounters(this.materialMatrix.uniforms.uCounter.value,0,1,0.02,1))}updateUniformCounters(a,b,c,d,e){let f=a;return 1==e?(f+=d*this.options.speedFactor,f>=c&&(f=b)):(f-=d*this.options.speedFactor,f<=c&&(f=b)),f}updatePostions(){this.dispose(),this.setData(this._data)}updateYoffset(){this.componentMesh.position.y=this.options.yOffset}updateMeshScale(){this.dispose(),this.setData(this._data)}updateMeshColor(){let a=e.Chroma(this.options.color).gl();this.materialWave.uniforms.uColor.value=new d.Vector3(a[0],a[1],a[2]),this.materialFire.uniforms.uColor.value=new d.Vector3(a[0],a[1],a[2]),this.materialCircle.uniforms.uColor.value=new d.Vector3(a[0],a[1],a[2]),this.materialMatrix.uniforms.uColor.value=new d.Vector3(a[0],a[1],a[2])}updateMeshItemVisible(){this.waveMesh.visible=this.options.displayWave,this.fireMesh.visible=this.options.displayFire,this.circleMesh.visible=this.options.displayCircle,this.matrixMesh.visible=this.options.displayMatrix}checkVisible(){let a=this.options;a.visible?this.show():this.hide()}hide(){this.options.visible=!1,this.componentMesh&&(this.componentMesh.visible=!1)}show(){this.options.visible=!0,this.componentMesh&&(this.componentMesh.visible=!0)}updateOptions(a){const b=e.deepClone(this.options);this.options=e.mergeOptions(this.options,a||{}),this.Utils.easyDiff(b.sceneName,a.sceneName)||(this.scene=this.getAssignedScene(),this.toggleScene(this.componentMesh,this.usingSceneName,a.sceneName)),this.updateMeshScale(),this.updateMeshItemVisible(),this.updateYoffset(),this.checkVisible()}disposeNode(a){a.traverse((a)=>{if(a.geometry&&a.geometry.dispose(),a.material){let b;a.material instanceof d.MeshFaceMaterial||a.material instanceof d.MultiMaterial?b=a.material.materials:a.material instanceof Array&&(b=a.material),b?b.forEach((a)=>{a.map&&a.map.dispose(),a.lightMap&&a.lightMap.dispose(),a.bumpMap&&a.bumpMap.dispose(),a.normalMap&&a.normalMap.dispose(),a.specularMap&&a.specularMap.dispose(),a.envMap&&a.envMap.dispose(),a.dispose()}):(a.material.map&&a.material.map.dispose(),a.material.lightMap&&a.material.lightMap.dispose(),a.material.bumpMap&&a.material.bumpMap.dispose(),a.material.normalMap&&a.material.normalMap.dispose(),a.material.specularMap&&a.material.specularMap.dispose(),a.material.envMap&&a.material.envMap.dispose(),a.material.dispose())}})}disposeMaterial(){this.materialWave=null,this.materialCircle=null,this.materialFire=null,this.materialMatrix=null}disposeComponentMeshes(){this.componentMesh=null,this.waveMesh=null,this.fireMesh=null,this.circleMesh=null,this.matrixMesh=null}dispose(){this.componentMesh&&(this.scene.remove(this.componentMesh),this.disposeNode(this.componentMesh),this.disposeComponentMeshes(),this.disposeMaterial())}remove(){this.dispose(),this._data=null}},a.exports});