// env=undefined => env=publish 
Cube("datav:/com/@datav-city-pro-v2/datav-engine-flyinglines/2.2.2/shader/line.vert.glsl",[],function(e,n,i,t,r,c){return e.exports="#define GLSLIFY 1\nuniform float thickness;\nuniform vec2 resolution;\n\nattribute float direction; // 线向两边扩展，两个方向\nattribute vec3 previous;\nattribute vec3 next;\nattribute vec2 uvs;\nattribute float animIndex;\n\nvarying vec2 v_uv;\nvarying float v_anim_index;\nvarying float v_line_width;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n  float aspect = resolution.x / resolution.y;\n  float pixelWidthRatio = 1. / (resolution.x * projectionMatrix[0][0]);\n  vec2 aspectVec = vec2(aspect, 1.0);\n  mat4 mvp = projectionMatrix * modelViewMatrix;\n\n  // into clip space\n  vec4 previousProjected = mvp * vec4(previous, 1.0);\n  vec4 currentProjected = mvp * vec4(position, 1.0);\n  vec4 nextProjected = mvp * vec4(next, 1.0);\n\n  // into NDC space [-1,1] and correct for aspect ratio(screenWidth/screenHeight)\n  vec2 currentScreen = currentProjected.xy / currentProjected.w * aspectVec;\n  vec2 previousScreen = previousProjected.xy / previousProjected.w * aspectVec;\n  vec2 nextScreen = nextProjected.xy / nextProjected.w * aspectVec;\n   \n  // 宽度\n  float pixelWidth = currentProjected.w * pixelWidthRatio;\n  #ifdef USE_SIZEATTENUATION\n    pixelWidth = 1.0;\n\t#endif\n\n  float lineWidth = 1.8 * pixelWidth * thickness;\n\n  vec2 dir = vec2(0.0);\n  if (position == previous) {\n    dir = normalize(nextScreen - currentScreen);\n  } else if (position == next) {\n    dir = normalize(currentScreen - previousScreen);\n  } else {\n    vec2 dirA = normalize(currentScreen - previousScreen);\n    vec2 dirB = normalize(nextScreen - currentScreen);\n    dir = normalize(dirA + dirB);\n    vec2 perp = vec2(-dirA.y, dirA.x);\n    vec2 miter = vec2(-dir.y, dir.x);\n    lineWidth = clamp( lineWidth / dot( miter, perp ), lineWidth, 1.5 * lineWidth);\n    // lineWidth = clamp( lineWidth / dot( miter, perp ), 0., 4. * thickness);\n  }\n\n  // 法线：\n  vec2 normal = vec2(-dir.y, dir.x);\n  normal.x /= aspect;\n  normal *= lineWidth * 0.5;\n\n  // uv\n  v_uv = uvs;\n  v_anim_index = animIndex;\n  v_line_width = lineWidth;\n\n  vec4 offset = vec4(normal * direction, 0.0, 0.0);//the w is not 1.0 otherwise offset represent a 3d point and cause unrealistic error.\n  gl_Position = currentProjected + offset;\n\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n  #include <fog_vertex>\n}",e.exports});;
Cube("datav:/com/@datav-city-pro-v2/datav-engine-flyinglines/2.2.2/shader/line.frag.glsl",[],function(n,t,a,o,e,i){return n.exports="#define GLSLIFY 1\nvarying vec2 v_uv;\nvarying float v_anim_index;\n\nuniform vec4 u_color;\nuniform float u_is_anim;\nuniform float u_line_length;\nuniform float u_time_counter;\nvarying float v_line_width;\n\nconst float HEAD_RATIO = 0.02;\n\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nfloat calculateTimeControlOpacity(float timeCounter, float p_index) {\n  float opacity = 0.;\n\n  float head = timeCounter;\n  float tail = head - u_line_length;\n\n  if(tail < .0){\n    if((p_index >= .0) && (p_index <= head))\n    opacity = p_index - tail;\n  } else if((tail >= .0) && (head <= 1.)){\n    if((p_index >= tail) && (p_index <= head)){\n      opacity = p_index - tail;\n    }\n  } else if(head > 1.0){\n    if((p_index >= tail) && (p_index <= 1.)){\n      opacity = p_index - tail;\n    }\n  }\n\n  opacity = mix(0., 1., opacity / u_line_length);\n  // opacity = pow(opacity, 1.2);\n  return opacity;\n}\n\nfloat CubicEaseOut(float t, float b, float c, float d) {\n  return c * ((t = t / d - 1.) * t * t + 1.) + b;\n}\n  \nfloat calculateHightColor(float uvPosition, float thickness, float intensity) {\n  float e = (1. - abs(uvPosition - 0.5)) * 0.5 + 0.5;\n  return pow(e * thickness, intensity);\n}\n\nfloat calculateEnhanceFactor(float downColor, float upColor, float color) {\n  return smoothstep(downColor, upColor, color);\n}\n\nfloat circle(in vec2 _st, in vec2 center, in float _radius){\n    vec2 l = _st - center;\n    return 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(l,l)*4.);\n}\n\nvoid main() {\n  #include <clipping_planes_fragment>\n  #include <logdepthbuf_fragment>\n\n  float opacity = 1.0;\n  float factor = 1.0;\n\n  #ifdef USE_ANIMATION\n    float i = calculateTimeControlOpacity(u_time_counter, v_anim_index);\n    opacity = CubicEaseOut(i, 0., 1., 1.);\n\n    #ifdef USE_HEAD\n      if(u_time_counter - v_uv.x > HEAD_RATIO) {\n        // 尾部\n        float a = 1. - smoothstep(0., 0.5, abs(v_uv.y - 0.5));\n        opacity *= a;\n      } else{\n        // 头部\n        vec2 center = vec2(u_time_counter, 0.5);\n        float factor1 = 1. - smoothstep(0., HEAD_RATIO / 2.0 ,  (HEAD_RATIO / 2.0 - (u_time_counter - v_uv.x) ));\n        float factor2 = 1. - smoothstep(0.25, 0.5, abs(v_uv.y - 0.5));\n        opacity *= (factor2 + factor1) / 2.0;\n      }\n\n    #else\n      factor = calculateHightColor(v_uv.y, 1.0, 1.05);\n      float enhanceFactor = calculateEnhanceFactor(0.05, 0.4, factor);\n      factor *= enhanceFactor;\n\n    #endif\n\n  #else\n    factor = calculateHightColor(v_uv.y, 1.0, 1.05);\n    float enhanceFactor = calculateEnhanceFactor(0.05, 0.4, factor);\n    factor *= enhanceFactor;\n\n  #endif  \n\n  #include <logdepthbuf_fragment>\n  #include <color_fragment>\n\n  // 后期渲染模块会统一做gamma校正，\n  // 为了图元渲染颜色和配置项设置颜色保持一致，需要做以下处理以抵消\n\tvec4 gammaBackColor = vec4(pow(u_color.r, 2.2), pow(u_color.g, 2.2),pow(u_color.b, 2.2), u_color.a);\n\n  gl_FragColor = vec4(vec3(factor), opacity) * gammaBackColor;\n\n  #include <premultiplied_alpha_fragment>\n  // #include <tonemapping_fragment>\n  // #include <encodings_fragment>\n  #include <fog_fragment>\n}",n.exports});;
Cube("datav:/com/@datav-city-pro-v2/datav-engine-flyinglines/2.2.2/flyingline",[],function(e,t,p,n,i,r){function o(e){return(o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function u(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function l(){return(l="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,n){var i=function(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=y(e)););return e}(e,t);if(i)return i=Object.getOwnPropertyDescriptor(i,t),i.get?i.get.call(arguments.length<3?e:n):i.value}).apply(this,arguments)}function c(e,t){return(c=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function h(n){var i=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(e){return!1}}();return function(){var e,t=y(n),t=(e=i?(e=y(this).constructor,Reflect.construct(t,arguments,e)):t.apply(this,arguments),this);if(e&&("object"===o(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");if(void 0!==t)return t;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}}function y(e){return(y=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}return e.exports=function(f){var m=f.THREE,d=f.Utils,n=f.VG,t=f.FormatTransformer,i=f.coordHelper,e=n.Layer,r=s;if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");r.prototype=Object.create(e&&e.prototype,{constructor:{value:r,writable:!0,configurable:!0}}),Object.defineProperty(r,"prototype",{writable:!1}),e&&c(r,e);var o,a=h(s);function s(e){var t;if(this instanceof s)return(t=a.call(this)).classNameAlias="FlyinglineLayer",t.layerName=t.classNameAlias,t.renderQueue=n.Geometry,t.needsAutoUpdate=!0,t.options=Object.assign({visible:!0},e||{}),t.needsWait=!0,t.defaultAltitude=0,t;throw new TypeError("Cannot call a class as a function")}return r=s,(e=[{key:"addTo",value:function(e){l(y(s.prototype),"addTo",this).call(this,e),this.formatTransformer=new t}},{key:"processing",value:function(e){var v=this;f.superWorker.executeAsPromise("MESHLINE",[e,{geoUV:!0,projType:i.crs,centerOffset:!0}]).then(function(e){if(e){for(var t=e.center,n=e.uvs,i=e.next,r=e.previous,o=e.position,a=e.indices,s=e.direction,u=e.entireAnimIndex,l=e.counter,c=0,f=0,p=0,e=new m.BufferGeometry,d=0;d<l.length;d++){f+=6*(l[d]-1);for(var h=0,y=c;y<f;y++)a[y]+=p,h=Math.max(h,a[y]);p=h+1,c=f}e.setIndex(new m.BufferAttribute(new Uint32Array(a),1)),e.setAttribute("direction",new m.BufferAttribute(new Float32Array(s),1)),e.setAttribute("position",new m.BufferAttribute(new Float32Array(o),3)),e.setAttribute("previous",new m.BufferAttribute(new Float32Array(r),3)),e.setAttribute("next",new m.BufferAttribute(new Float32Array(i),3)),e.setAttribute("uvs",new m.BufferAttribute(new Float32Array(n),2)),e.setAttribute("animIndex",new m.BufferAttribute(new Float32Array(u),1)),e.computeBoundingSphere(),e.computeBoundingBox();s=v.initMaterial(),o=new m.Mesh(e,s);o.position.fromArray(t),o.matrix.setPosition(o.position),o.frustumCulled=!1,v.group.ignoreWaterReflection=!0,v.add(o),v.emit("rendered"),v.needsWait=!1}})}},{key:"getSliceIndex",value:function(e,t,n){return[0===t?0:e.slice(0,t).reduce(function(e,t){return e+t},0)*n,e.slice(0,t+1).reduce(function(e,t){return e+t},0)*n]}},{key:"initMaterial",value:function(){var e=this.options.options,t=e.general,n=e.graph,e=e.animate,i=t.blendingType,r=t.depthTest,r=void 0===r||r,o=t.depthWrite,o=void 0===o||o,t=t.sizeAttenuation,t=void 0===t||t,a=n.isUseHead,s=n.length,u=n.lineColor,n=n.lineWidth,l=e.isAnim,e=e.syncEmit,u=d.Chroma(u).gl(),c=new m.Vector2,n=(f.viewer.engine.renderer.getSize(c),new m.ShaderMaterial({uniforms:m.UniformsUtils.merge([m.UniformsLib.fog,{thickness:{value:n},resolution:{value:c},u_color:{value:new m.Vector4(u[0],u[1],u[2],u[3])},u_time_counter:{value:e?0:Math.random()},u_line_length:{value:s}}]),defines:{USE_SIZEATTENUATION:t,USE_ANIMATION:l,USE_HEAD:a},fog:!0,depthWrite:o,depthTest:r,transparent:!0,side:m.DoubleSide,blending:m[i],fragmentShader:p("datav:/com/@datav-city-pro-v2/datav-engine-flyinglines/2.2.2/shader/line.frag.glsl"),vertexShader:p("datav:/com/@datav-city-pro-v2/datav-engine-flyinglines/2.2.2/shader/line.vert.glsl")}));return n.userData.opacity=u[3],n}},{key:"setData",value:function(e){var o=this;if(!e)return console.log("flyingLine layer no data");var t=e;if(!Array.isArray(e)){if("FeatureCollection"!==e.type)return console.log("flylingLine: invalid data format. ",e);t=this.formatTransformer.geojson2datav(e)}if(this.clear(),!t.length)return console.log("flylingLine layer no data");this.data=e;var e=this.options.options.general.offsetHeight,a=void 0===e?0:e,t=t.map(function(e){for(var e=(e.geometry||{}).coordinates,t=void 0===e?[]:e,n=[],i=0,r=t.length;i<r;i++)n.push({x:t[i][0],y:t[i][1],z:(t[i][2]||o.defaultAltitude)+a});return n});this.processing(t),this.checkVisible()}},{key:"dataErrorHandler",value:function(){this.emit("rendered"),this.needsWait=!1}},{key:"checkVisible",value:function(){this.options.visible?this.show():this.hide()}},{key:"updateMaterial",value:function(){var e=this.options.options,t=e.general,n=e.graph,e=e.animate,i=t.blendingType,r=t.depthWrite,o=void 0===r||r,r=t.depthTest,a=void 0===r||r,r=t.sizeAttenuation,s=void 0===r||r,u=n.isUseHead,l=n.length,t=n.lineColor,c=n.lineWidth,f=e.isAnim,p=d.Chroma(t).gl();this.traverseAll(function(e){e instanceof m.Mesh&&((e=e.material).uniforms.u_color.value=new m.Vector4(p[0],p[1],p[2],p[3]),e.uniforms.u_line_length.value=l,e.uniforms.thickness.value=c,e.blending=m[i],e.depthTest=a,e.depthWrite=o,e.defines.USE_SIZEATTENUATION=s,e.defines.USE_ANIMATION=f,e.defines.USE_HEAD=u,e.needsUpdate=!0,e.userData.opacity=p[3])})}},{key:"setOpacity",value:function(n){this.traverseAll(function(e){var t;e instanceof m.Mesh&&(t=(e=e.material).userData.opacity*n,e.uniforms.u_color.value.setW(t))})}},{key:"updadeSyncEmit",value:function(){var t=this.options.syncEmit;this.traverseAll(function(e){e instanceof m.Mesh&&(e.material.uniforms.u_time_counter.value=t?0:Math.random())})}},{key:"updateOptions",value:function(e){var t=d.deepClone(this.options);this.options=d.mergeOptions(this.options,e||{}),this.updateMaterial(),!this.options.forceEmit&&d.easyDiff(t.syncEmit,this.options.syncEmit)||this.updadeSyncEmit(),d.easyDiff(t.sceneId.length,e.sceneId.length)&&d.deepDiff(t.sceneId,e.sceneId)||this.updateSceneId(),d.easyDiff(t.visible,this.options.visible)||this.checkVisible(),d.easyDiff(t.options.general.offsetHeight,this.options.options.general.offsetHeight)||this.setData(this.data)}},{key:"animate",value:function(){var e=this.options.options,t=e.graph,e=e.animate,n=t.length,i=e.speed;this.traverseAll(function(e){e instanceof m.Mesh&&((e=e.material).uniforms.u_time_counter.value<=1+n?e.uniforms.u_time_counter.value+=.5*i:e.uniforms.u_time_counter.value=0)})}},{key:"autoUpdate",value:function(){this.animate()}},{key:"show",value:function(){this.options.visible=!0,l(y(s.prototype),"show",this).call(this)}},{key:"hide",value:function(){this.options.visible=!1,l(y(s.prototype),"hide",this).call(this)}},{key:"clear",value:function(){l(y(s.prototype),"clear",this).call(this)}},{key:"destroy",value:function(){l(y(s.prototype),"destroy",this).call(this)}}])&&u(r.prototype,e),o&&u(r,o),Object.defineProperty(r,"prototype",{writable:!1}),s},e.exports});;
Cube("datav:/com/@datav-city-pro-v2/datav-engine-flyinglines/2.2.2",["datav:/npm/eventemitter3/3.0.0"],function(e,t,r,n,o,i){function a(e){return(a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function l(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function c(e,t){return(c=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function u(r){var n=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(e){return!1}}();return function(){var e,t=y(r),t=(e=n?(e=y(this).constructor,Reflect.construct(t,arguments,e)):t.apply(this,arguments),this);if(e&&("object"===a(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");if(void 0!==t)return t;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}}function y(e){return(y=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var s=r("datav:/npm/eventemitter3/3.0.0"),f=r("datav:/com/@datav-city-pro-v2/datav-engine-flyinglines/2.2.2/flyingline"),r=function(){var e=o,t=s;if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&c(e,t);var r,n=u(o);function o(e,t){var r;if(this instanceof o)return(r=n.call(this)).options=t,r.comId="",r;throw new TypeError("Cannot call a class as a function")}return e=o,(t=[{key:"addTo",value:function(e,t){return this.cityproCore=e,this.comId=t,this.initLayer()}},{key:"initLayer",value:function(){var e=f(this.cityproCore);this.layer=new e(this.options),this.cityproCore.viewer.addLayer(this.comId,this.layer)}},{key:"setData",value:function(e){this.layer&&this.layer.setData(e)}},{key:"setOpacity",value:function(e){this.layer&&this.layer.setOpacity(e)}},{key:"errorRender",value:function(){console.log("动态轨迹线组件数据错误"),this.layer&&this.layer.dataErrorHandler()}},{key:"updateOptions",value:function(e){this.layer&&this.layer.updateOptions&&this.layer.updateOptions(e)}},{key:"getThemableConfig",value:function(e){return{lineColor:e.line.flylineColor}}},{key:"show",value:function(){this.layer&&this.layer.show&&this.layer.show()}},{key:"hide",value:function(){this.layer&&this.layer.hide&&this.layer.hide()}},{key:"remove",value:function(){console.log("remove is duplicate, please use clear instead.",this),this.clear()}},{key:"clear",value:function(){this.layer&&this.layer.clear&&this.layer.clear()}},{key:"destroy",value:function(){this.layer&&(this.layer.destroy&&this.layer.destroy(),this.layer=null)}}])&&l(e.prototype,t),r&&l(e,r),Object.defineProperty(e,"prototype",{writable:!1}),o}();return e.exports=r,e.exports});