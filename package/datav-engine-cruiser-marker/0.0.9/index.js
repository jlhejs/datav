// env=undefined => env=publish 
Cube("datav:/com/datav-engine-cruiser-marker/0.0.9/shaders/spot.frag.glsl",[],function(a){return a.exports="#ifdef GL_ES\n  precision highp float;\n#define GLSLIFY 1\n#endif\n\n#include <logdepthbuf_pars_fragment>\n\nuniform vec3 uColor;\nuniform float uCounter;\nvarying vec2 vUv;\n\nfloat circle(float radius, vec2 center, vec2 uv);\nvec2 angleRadius(vec2 uv);\nfloat filterPositive(float n);\n\nvoid main() {\n  #include <logdepthbuf_fragment>\n  vec2 offsetUv = vUv - 0.5;\n\n  float isPaintingPixel = 0.0;\n\n  float radius = 0.3;\n  float ringThick = 0.05;\n  \n  vec2 stPolar = angleRadius(offsetUv);\n  \n  float sPolar = stPolar.x * 5.0 + uCounter * 10.0;\n  float cosSPolarTemp = cos(sPolar);\n  float cosSPolar = filterPositive(cosSPolarTemp);\n\n  // isPaintingPixel += cosSPolar; //\u6807\u8BB0\u8BE5\u50CF\u7D20\u7740\u8272\uFF0Calpha\u901A\u9053\u4E0D\u4E3A\u96F6\n  \n  vec3 color = vec3(cosSPolar);\n  \n  float inCircleAA = smoothstep(radius, radius + 0.005, angleRadius(offsetUv).y); //AA version\n  float smallCircleAA = smoothstep(radius - ringThick, radius - ringThick + 0.005, angleRadius(offsetUv).y); //AA version\n  vec3 col = 1.0 - vec3(inCircleAA);\n  vec3 col_2 = 1.0 - vec3(smallCircleAA);\n  vec3 colorGap = col - col_2;\n  vec3 finalColor = color * colorGap;\n  // vec3 colorMask = vec3(10, 1.5, 1.0);\n  vec3 colorMask = uColor;\n  finalColor /= 10.0;\n  finalColor *= colorMask;\n\n  isPaintingPixel += finalColor.x; //\u6807\u8BB0\u8BE5\u50CF\u7D20\u7740\u8272\uFF0Calpha\u901A\u9053\u4E0D\u4E3A\u96F6\n  \n  float centerCircleAA = smoothstep(0.1, 0.1 + 0.005, angleRadius(offsetUv).y); //AA version\n  vec3 centerCircleColor = 1.0 - vec3(centerCircleAA);\n  centerCircleColor /= 10.0;\n  centerCircleColor *= colorMask;\n\n  isPaintingPixel += centerCircleColor.x; //\u6807\u8BB0\u8BE5\u50CF\u7D20\u7740\u8272\uFF0Calpha\u901A\u9053\u4E0D\u4E3A\u96F6\n  \n  vec2 centerC = vec2(0.0, 0.0);\n  float bubbleRadius = abs(sin(uCounter * 3.0)) / 3.0;\n  float bubbleCircleColor = circle(bubbleRadius, centerC, offsetUv);\n  vec4 bubbleColor = vec4(vec3(bubbleCircleColor) / 10.0 * colorMask, 1.0);\n\n  isPaintingPixel += bubbleColor.x; //\u6807\u8BB0\u8BE5\u50CF\u7D20\u7740\u8272\uFF0Calpha\u901A\u9053\u4E0D\u4E3A\u96F6\n  \n  gl_FragColor = vec4(finalColor + centerCircleColor, 1.0);\n  gl_FragColor += bubbleColor;\n  gl_FragColor *= 7.0;\n\n  //\u6807\u8BB0\u8BE5\u50CF\u7D20\u7740\u8272alpha\u901A\u9053\u662F\u5426\u96F6\n  // isPaintingPixel = clamp(0.0, 1.0, isPaintingPixel);\n  // if(isPaintingPixel < 0.0001) {\n  //   discard;\n  // } else {\n  //   gl_FragColor = vec4(gl_FragColor.xyz, isPaintingPixel * 1000.0);\n  // }\n\n  isPaintingPixel = step(0.0000001, isPaintingPixel);\n  \n  gl_FragColor = vec4(gl_FragColor.xyz, isPaintingPixel);\n  // gl_FragColor.x = step(0.0000001, gl_FragColor.x);\n\n  // gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n  #include <premultiplied_alpha_fragment>  \n}\n\nfloat circle(float radius, vec2 center, vec2 uv) {\n\tfloat d = distance(center, uv);\n  \n  // return 1.0 - smoothstep(radius-1./iResolution.y, radius+1./iResolution.y, d);\n  return 1.0 - smoothstep(radius-1.0/512.0, radius+1.0/512.0, d);\n}\n\nvec2 angleRadius(vec2 uv) {\n  float twoPi = 6.2831853;\n\tfloat anglePixel = atan(uv.y, uv.x);\n  float lengthPixel = length(uv);\n  \n  return vec2(anglePixel, lengthPixel);\n}\n\nfloat filterPositive(float n) {\n  return smoothstep(0.0, 0.005, n);\n}",a.exports});;
Cube("datav:/com/datav-engine-cruiser-marker/0.0.9/shaders/line.frag.glsl",[],function(a){return a.exports="#ifdef GL_ES\n  precision highp float;\n#define GLSLIFY 1\n#endif\n\n#include <logdepthbuf_pars_fragment>\n\nuniform vec3 uColor;\nvarying vec2 vUv;\n\nfloat calculateLineOpacity(vec2 uv);\n\nvoid main() {\n  #include <logdepthbuf_fragment>\n\n  float opacityY = calculateLineOpacity(vUv);\n\n  if(opacityY < 0.02) {\n    discard;\n  }\n\n  gl_FragColor = vec4(uColor, opacityY);\n\n  #include <premultiplied_alpha_fragment>  \n}\n\nfloat calculateLineOpacity(vec2 uv) {\n  float uvY = uv.y;\n\n  float opacity = pow((1.0 - uvY), 1.5);\n\n  return opacity;\n}",a.exports});;
Cube("datav:/com/datav-engine-cruiser-marker/0.0.9/shaders/circle.vert.glsl",[],function(a){return a.exports="#define GLSLIFY 1\n#include <logdepthbuf_pars_vertex>\n\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n  #include <logdepthbuf_vertex>\n}",a.exports});;
Cube("datav:/com/datav-engine-cruiser-marker/0.0.9/shaders/circle.frag.glsl",[],function(a){return a.exports="#ifdef GL_ES\n  precision highp float;\n#define GLSLIFY 1\n#endif\n\n#include <logdepthbuf_pars_fragment>\n\nuniform float uTimeCounter;\nuniform vec3 uColor;\nvarying vec2 vUv;\n\nfloat calOpacityByPolarDistance(float polarLength, float startPoint);\nfloat calculateHightColor(float uvPosition, float thickness, float intensity);\nfloat tweenBounceOut(float k);\nfloat tweenBounceIn(float k);\nfloat tweenBounceInOut(float k);\n\nvoid main() {\n  #include <logdepthbuf_fragment>\n\n  vec2 polarSt = vec2(atan(vUv.x-0.5, vUv.y-0.5), distance(vUv, vec2(0.5, 0.5)));\n\n  float thickness = 1.0;\n  float intensity = 1.1;\n  float transparentStartUv = 0.1;\n  float col = 10.0;\n  float uvY = polarSt.y * col;\n\n  float fractUvY = fract(uvY + uTimeCounter);\n  float centerY = 0.5;\n  float barColor = calculateHightColor(fractUvY, thickness, intensity);\n\n  if(polarSt.y <= 0.5) {\n    barColor *= calOpacityByPolarDistance(polarSt.y, transparentStartUv);\n  } else {\n    barColor = 0.0;\n  }\n\n  gl_FragColor = vec4(barColor);\n\n  // vec4 colorMask = vec4(0.7, 1.0, 2.1, 1.0);\n  vec4 colorMask = vec4(uColor, 1.0);\n  gl_FragColor *= colorMask;\n\n  #include <premultiplied_alpha_fragment>\n}\n\nfloat calculateHightColor(float uvPosition, float thickness, float intensity) {\n  float e = (0.5 - abs(uvPosition - 0.5)) / 0.5;\n  return pow(e * thickness, intensity);\n}\n\nfloat calOpacityByPolarDistance(float polarLength, float startPoint) {\n  float totalPolarLength = 0.5;\n  float opacity = 1.0;\n  if(polarLength > startPoint) {\n    float distancePercent = (totalPolarLength - polarLength) / (totalPolarLength - startPoint);\n    return pow(distancePercent, 2.0);\n  } else {\n    return 1.0;\n  }\n}\n\nfloat tweenBounceOut(float k) {\n  if (k < (1.0 / 2.75)) {\n    return 7.5625 * k * k;\n  } else if (k < (2.0 / 2.75)) {\n    return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n  } else if (k < (2.5 / 2.75)) {\n    return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n  } else {\n    return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n  }\n}\n\nfloat tweenBounceIn(float k) {\n  return 1.0 - tweenBounceOut(1.0 - k);\n}\n\nfloat tweenBounceInOut(float k) {\n  if (k < 0.5) {\n    return tweenBounceIn(k * 2.0) * 0.5;\n  }\n\n  return tweenBounceOut(k * 2.0 - 1.0) * 0.5 + 0.5;\n}",a.exports});;
Cube("datav:/com/datav-engine-cruiser-marker/0.0.9/layer",["datav:/npm/eventemitter3/3.0.0"],function(a,b,c){const d=c("datav:/npm/eventemitter3/3.0.0");return a.exports=class extends d{constructor(){super(),this.preSceneName="main",this.usingSceneName="main"}addTo(a){return a?void(this.viewer=a,this.Utils=a.Utils,this.controller=a.controller,this.scene=this.getAssignedScene(),this.viewer.on("projChanged",this.updatePostions.bind(this))):console.log("Layer needs viewer layer")}getProjPos(a,b,c){return this.viewer&&this.viewer.Projection([a,b,c])}updatePostions(){}getAssignedScene(){const a=this.options;return a.isSceneGroup&&a.sceneName?a.sceneName?this.controller.getScene(a.sceneName)?this.controller.getScene(a.sceneName):this.controller.createScene(a.sceneName):void 0:this.controller.getScene("main")}toggleScene(a,b,c){this.controller.switchScene(a,b,c).then(()=>{this.preSceneName=b,this.usingSceneName=c})}updateOptions(){}},a.exports});;
Cube("datav:/com/datav-engine-cruiser-marker/0.0.9/shaders/spot.vert.glsl",[],function(a){return a.exports="#define GLSLIFY 1\n#include <logdepthbuf_pars_vertex>\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv  = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n  #include <logdepthbuf_vertex>\n}",a.exports});;
Cube("datav:/com/datav-engine-cruiser-marker/0.0.9/shaders/line.vert.glsl",[],function(a){return a.exports="#define GLSLIFY 1\n#include <logdepthbuf_pars_vertex>\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv  = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n  #include <logdepthbuf_vertex>\n}",a.exports});;
Cube("datav:/com/datav-engine-cruiser-marker/0.0.9",[],function(a,b,c){let d=null,e=null;const f=c("datav:/com/datav-engine-cruiser-marker/0.0.9/layer"),g=c("datav:/com/datav-engine-cruiser-marker/0.0.9/shaders/circle.vert.glsl"),h=c("datav:/com/datav-engine-cruiser-marker/0.0.9/shaders/circle.frag.glsl"),i=c("datav:/com/datav-engine-cruiser-marker/0.0.9/shaders/spot.vert.glsl"),j=c("datav:/com/datav-engine-cruiser-marker/0.0.9/shaders/spot.frag.glsl"),k=c("datav:/com/datav-engine-cruiser-marker/0.0.9/shaders/line.vert.glsl"),l=c("datav:/com/datav-engine-cruiser-marker/0.0.9/shaders/line.frag.glsl");return a.exports=class extends f{constructor(a,b){super(),this.options=Object.assign({isSceneGroup:!1,sceneName:"",color:"#ff3300",scaleFactor:1,spotHeight:30,speed:1e-3,yOffset:0,visible:!0},b||{})}addTo(a){return a?void(super.addTo(a),d=a.three,e=a.Utils,this.animation=this.animation.bind(this),this.viewer.on("animationFrame",this.animation),this.cruiserCounter=0,this.parentClearColor="",this.blendTypeList=[]):console.log("Cruiser Marker layer needs viewer layer")}createMesh(a){let b=new d.Group;return this.createCruiserPath(a),this.circleMesh=this.createMeshCircle(a),b.add(this.circleMesh),this.spotMesh=this.createSpotMesh(),b.add(this.spotMesh),this.lineMesh=this.createLineMesh(),b.add(this.lineMesh),b}createMeshCircle(){let a=e.Chroma(this.options.color).gl(),b=new d.PlaneBufferGeometry(20,20,1,1);this.materialCircle=new d.ShaderMaterial({uniforms:{uColor:{value:new d.Vector3(a[0],a[1],a[2])},uTimeCounter:{value:1e4},uCounter:{value:0}},vertexShader:g,fragmentShader:h,transparent:!0,opacity:1,blending:d[this.options.blendType],depthWrite:!1,side:d.DoubleSide});var c=new d.Mesh(b,this.materialCircle);return c.renderOrder=4e3,c.scale.set(this.options.scaleFactor,this.options.scaleFactor,this.options.scaleFactor),c.rotation.x=Math.PI/2,c}createLineMesh(){let a=e.Chroma(this.options.color).gl(),b=new d.CylinderBufferGeometry(0.2,0.2,this.options.spotHeight,8);this.materialLine=new d.ShaderMaterial({uniforms:{uColor:{value:new d.Vector3(a[0],a[1],a[2])},uTimeCounter:{value:1e4}},vertexShader:k,fragmentShader:l,transparent:!0,blending:d[this.options.blendType],depthWrite:!1,side:d.DoubleSide});let c=new d.Mesh(b,this.materialLine);return c.scale.set(this.options.scaleFactor,this.options.scaleFactor,this.options.scaleFactor),c.renderOrder=4e3,c.position.y=this.options.spotHeight*this.options.scaleFactor/2,c}createSpotMesh(){this.createSpotRttEnv(),this.createSpotRtt(),this.spriteMaterial=new d.SpriteMaterial({map:this.rtTextureSpot.texture,transparent:!0,depthTest:!1,blending:d[this.options.blendType]}),this.spriteMaterial.map.minFilter=d.LinearMipMapLinearFilter,this.spriteMaterial.map.magFilter=d.LinearFilter;let a=new d.Sprite(this.spriteMaterial),b=15;return a.scale.set(b*this.options.scaleFactor,b*this.options.scaleFactor,1),a.renderOrder=0,a.position.y=this.options.spotHeight*this.options.scaleFactor,a}createSpotRttEnv(){this.cameraRttSpot=new d.OrthographicCamera(-256,256,256,-256,-1e4,1e4),this.cameraRttSpot.position.z=0,this.sceneRttSpot=new d.Scene,this.rtTextureSpot=new d.WebGLRenderTarget(512,512,{format:d.RGBAFormat,magFilter:d.LinearMipMapLinearFilter,minFilter:d.LinearFilter})}createSpotRtt(){let a=e.Chroma(this.options.color).gl();this.materialRttSpot=new d.ShaderMaterial({uniforms:{uCounter:{value:0.5},uColor:{value:new d.Vector3(a[0],a[1],a[2])}},vertexShader:i,fragmentShader:j,side:d.DoubleSide,transparent:!0,blending:d.NormalBlending});let b=new d.PlaneBufferGeometry(512,512),c=new d.Mesh(b,this.materialRttSpot);this.sceneRttSpot.add(c)}createCruiserPath(a){let b=[];a.forEach((a)=>{b.push(new d.Vector2(a.x,a.z))}),this.cruiserPath=new d.Path(b)}moveCruiser(){let a=this.cruiserPath.getPointAt(this.cruiserCounter),b=new d.Vector3(a.x,this.options.yOffset,a.y);this.componentMesh.position.copy(b)}projectData(a){return a.map((a)=>{let b=this.getProjPos(a.x,a.y,a.z);return{x:b[0],y:b[1],z:b[2]}})}setData(a){if(!a||!Array.isArray(a))return console.log("error: no data for animation marker component.");if(this.dispose(),!a.length)return console.log("error: wrong data format for animation marker component.");this._data=a;let b=this.projectData(a);this.componentMesh=this.createMesh(b),this.scene.add(this.componentMesh),this.checkVisible()}animation(){this.componentMesh&&(this.materialCircle.uniforms.uTimeCounter.value=this.updateUniformCounters(this.materialCircle.uniforms.uTimeCounter.value,1e4,0,0.03,0),this.materialRttSpot.uniforms.uCounter.value=this.updateUniformCounters(this.materialRttSpot.uniforms.uCounter.value,0,6.2831853,0.02,1),this.cruiserCounter=this.updateUniformCounters(this.cruiserCounter,0,1,this.options.speed,1),this.moveCruiser(),this.parentClearColor=this.viewer.renderer.getClearColor(),this.parentClearAlpha=this.viewer.renderer.getClearAlpha(),this.viewer.renderer.setClearColor(65280,0),this.viewer.renderer.render(this.sceneRttSpot,this.cameraRttSpot,this.rtTextureSpot,!0),this.viewer.renderer.setClearColor(this.parentClearColor,this.parentClearAlpha))}updateUniformCounters(a,b,c,d,e){let f=a;return 1==e?(f+=d,f>=c&&(f=b)):(f-=d,f<=c&&(f=b)),f}updatePostions(){this.dispose(),this.setData(this._data)}updateMeshScale(){this.dispose(),this.setData(this._data)}updateSpotHeight(){this.dispose(),this.setData(this._data)}updateMeshColor(){let a=e.Chroma(this.options.color).gl();this.materialCircle.uniforms.uColor.value=new d.Vector3(a[0],a[1],a[2])}updateMeshItemVisible(){this.circleMesh.visible=this.options.displayCircle}checkVisible(){let a=this.options;a.visible?this.show():this.hide()}hide(){this.options.visible=!1,this.componentMesh&&(this.componentMesh.visible=!1)}show(){this.options.visible=!0,this.componentMesh&&(this.componentMesh.visible=!0)}updateOptions(a){const b=this.Utils.deepClone(this.options);this.options=this.Utils.mergeOptions(this.options,a||{}),this.Utils.easyDiff(b.sceneName,a.sceneName)||(this.scene=this.getAssignedScene(),this.toggleScene(this.componentMesh,this.usingSceneName,a.sceneName)),this.updateMeshScale(),this.updateSpotHeight(),this.checkVisible()}disposeNode(a){a.traverse((a)=>{if(a.geometry&&a.geometry.dispose(),a.material){let b;a.material instanceof d.MeshFaceMaterial||a.material instanceof d.MultiMaterial?b=a.material.materials:a.material instanceof Array&&(b=a.material),b?b.forEach((a)=>{a.map&&a.map.dispose(),a.lightMap&&a.lightMap.dispose(),a.bumpMap&&a.bumpMap.dispose(),a.normalMap&&a.normalMap.dispose(),a.specularMap&&a.specularMap.dispose(),a.envMap&&a.envMap.dispose(),a.dispose()}):(a.material.map&&a.material.map.dispose(),a.material.lightMap&&a.material.lightMap.dispose(),a.material.bumpMap&&a.material.bumpMap.dispose(),a.material.normalMap&&a.material.normalMap.dispose(),a.material.specularMap&&a.material.specularMap.dispose(),a.material.envMap&&a.material.envMap.dispose(),a.material.dispose())}})}disposeMaterial(){this.materialCircle=null,this.materialRttSpot=null,this.spriteMaterial=null}disposeComponentMeshes(){this.componentMesh=null,this.circleMesh=null}disposeRtt(){this.rtTextureSpot.dispose(),this.disposeNode(this.sceneRttSpot),this.cameraRttSpot=null,this.sceneRttSpot=null,this.rtTextureSpot=null}dispose(){this.componentMesh&&(this.scene.remove(this.componentMesh),this.disposeNode(this.componentMesh),this.disposeComponentMeshes(),this.disposeMaterial(),this.disposeRtt())}remove(){this.dispose(),this._data=null}},a.exports});